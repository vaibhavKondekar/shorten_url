#### **Normalization:**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <string>

\#include <climits>

\#include <iomanip>

\#include <cmath>

using namespace std;



// ---------- Read CSV ----------

vector<vector<string>> read\_csv(string \&filename) {

&nbsp;   vector<vector<string>> data;

&nbsp;   ifstream file(filename);

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error opening file!" << endl;

&nbsp;       return data;

&nbsp;   }



&nbsp;   string line;

&nbsp;   while (getline(file, line)) {

&nbsp;       vector<string> row;

&nbsp;       string cell;

&nbsp;       stringstream ss(line);

&nbsp;       while (getline(ss, cell, ',')) {

&nbsp;           row.push\_back(cell);

&nbsp;       }

&nbsp;       data.push\_back(row);

&nbsp;   }

&nbsp;   file.close();

&nbsp;   return data;

}



// ---------- Min-Max Normalization ----------

vector<vector<double>> minMaxNormalize(vector<vector<double>> \&data, double newMin, double newMax) {

&nbsp;   int rows = data.size();

&nbsp;   int cols = data\[0].size();



&nbsp;   vector<double> minVal(cols, INT\_MAX), maxVal(cols, INT\_MIN);



&nbsp;   for (int j = 0; j < cols; j++) {

&nbsp;       for (int i = 0; i < rows; i++) {

&nbsp;           if (data\[i]\[j] < minVal\[j]) minVal\[j] = data\[i]\[j];

&nbsp;           if (data\[i]\[j] > maxVal\[j]) maxVal\[j] = data\[i]\[j];

&nbsp;       }

&nbsp;   }



&nbsp;   vector<vector<double>> normalized(rows, vector<double>(cols, 0));

&nbsp;   for (int i = 0; i < rows; i++) {

&nbsp;       for (int j = 0; j < cols; j++) {

&nbsp;           if (maxVal\[j] != minVal\[j])

&nbsp;               normalized\[i]\[j] = (data\[i]\[j] - minVal\[j]) / (maxVal\[j] - minVal\[j]) \* (newMax - newMin) + newMin;

&nbsp;           else

&nbsp;               normalized\[i]\[j] = 0;

&nbsp;       }

&nbsp;   }

&nbsp;   return normalized;

}



// ---------- Z-Score Normalization ----------

vector<vector<double>> zScoreNormalize(vector<vector<double>> \&data) {

&nbsp;   int rows = data.size();

&nbsp;   int cols = data\[0].size();



&nbsp;   vector<double> mean(cols, 0), stddev(cols, 0);



&nbsp;   for (int j = 0; j < cols; j++) {

&nbsp;       double sum = 0;

&nbsp;       for (int i = 0; i < rows; i++) sum += data\[i]\[j];

&nbsp;       mean\[j] = sum / rows;



&nbsp;       double sq\_sum = 0;

&nbsp;       for (int i = 0; i < rows; i++) sq\_sum += pow(data\[i]\[j] - mean\[j], 2);

&nbsp;       stddev\[j] = sqrt(sq\_sum / rows);

&nbsp;   }



&nbsp;   vector<vector<double>> normalized(rows, vector<double>(cols, 0));

&nbsp;   for (int i = 0; i < rows; i++) {

&nbsp;       for (int j = 0; j < cols; j++) {

&nbsp;           if (stddev\[j] != 0)

&nbsp;               normalized\[i]\[j] = (data\[i]\[j] - mean\[j]) / stddev\[j];

&nbsp;           else

&nbsp;               normalized\[i]\[j] = 0;

&nbsp;       }

&nbsp;   }

&nbsp;   return normalized;

}



// ---------- Write CSV ----------

void write\_csv(string filename, vector<vector<string>> \&header, vector<vector<double>> \&normalized) {

&nbsp;   ofstream output(filename);

&nbsp;   int cols = header\[0].size();



&nbsp;   for (int i = 0; i < cols; i++) {

&nbsp;       output << header\[0]\[i];

&nbsp;       if (i < cols - 1) output << ",";

&nbsp;   }

&nbsp;   output << "\\n";



&nbsp;   for (int i = 0; i < normalized.size(); i++) {

&nbsp;       for (int j = 0; j < cols; j++) {

&nbsp;           output << fixed << setprecision(2) << normalized\[i]\[j];

&nbsp;           if (j < cols - 1) output << ",";

&nbsp;       }

&nbsp;       output << "\\n";

&nbsp;   }

&nbsp;   output.close();

}



int main() {

&nbsp;   string filename = "data.csv";

&nbsp;   vector<vector<string>> data = read\_csv(filename);



&nbsp;   if (data.empty()) {

&nbsp;       cout << "Empty file!" << endl;

&nbsp;       return 0;

&nbsp;   }



&nbsp;   vector<string> header = data\[0];

&nbsp;   data.erase(data.begin());



&nbsp;   int rows = data.size();

&nbsp;   int cols = data\[0].size();



&nbsp;   vector<vector<double>> double\_data(rows, vector<double>(cols, 0));

&nbsp;   for (int i = 0; i < rows; i++) {

&nbsp;       for (int j = 0; j < cols; j++) {

&nbsp;           try {

&nbsp;               double\_data\[i]\[j] = stod(data\[i]\[j]);

&nbsp;           } catch (...) {

&nbsp;               double\_data\[i]\[j] = 0;

&nbsp;           }

&nbsp;       }

&nbsp;   }



&nbsp;   // ----- Perform both normalizations -----

&nbsp;   vector<vector<double>> minmax = minMaxNormalize(double\_data, 0, 1);

&nbsp;   vector<vector<double>> zscore = zScoreNormalize(double\_data);



&nbsp;   // ----- Write results -----

&nbsp;   vector<vector<string>> headerVec = { header };

&nbsp;   write\_csv("normalized\_minmax.csv", headerVec, minmax);

&nbsp;   write\_csv("normalized\_zscore.csv", headerVec, zscore);



&nbsp;   cout << "✅ Min-Max and Z-Score normalization completed.\\n";

&nbsp;   cout << "Files saved as 'normalized\_minmax.csv' and 'normalized\_zscore.csv'.\\n";



&nbsp;   return 0;

}

Age,Height,Weight

18,165,58

19,170,62

20,172,65

21,168,60

22,175,68

23,180,70

24,178,72

25,182,75

26,176,69

27,174,71





### **2.olap**



\#include <bits/stdc++.h>

using namespace std;



// Read CSV file

vector<map<string, string>> readCSV(const string\& fileName, vector<string>\& header) {

&nbsp;   vector<map<string, string>> records;

&nbsp;   ifstream file(fileName);

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error opening file!" << endl;

&nbsp;       return records;

&nbsp;   }

&nbsp;   string line;

&nbsp;   if (!getline(file, line)) return records;

&nbsp;   stringstream ss(line);

&nbsp;   string col;

&nbsp;   while (getline(ss, col, ',')) header.push\_back(col);



&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream row(line);

&nbsp;       string value;

&nbsp;       map<string, string> record;

&nbsp;       for (int i = 0; i < header.size(); i++) {

&nbsp;           getline(row, value, ',');

&nbsp;           record\[header\[i]] = value;

&nbsp;       }

&nbsp;       records.push\_back(record);

&nbsp;   }

&nbsp;   return records;

}



// Print record

void printRecord(const map<string, string>\& r, const vector<string>\& header) {

&nbsp;   for (const string\& h : header)

&nbsp;       cout << r.at(h) << " | ";

&nbsp;   cout << endl;

}



// ✅ Renamed from 'slice' to 'sliceData'

void sliceData(const vector<map<string, string>>\& data, const string\& field,

&nbsp;              const string\& value, const vector<string>\& header) {

&nbsp;   cout << "\\nSlice: " << field << " = " << value << endl;

&nbsp;   for (const auto\& r : data)

&nbsp;       if (r.at(field) == value)

&nbsp;           printRecord(r, header);

}



// Dice

void dice(const vector<map<string, string>>\& data, const map<string, string>\& filters,

&nbsp;         const vector<string>\& header) {

&nbsp;   cout << "\\nDice result:\\n";

&nbsp;   for (const auto\& r : data) {

&nbsp;       bool match = true;

&nbsp;       for (const auto\& f : filters)

&nbsp;           if (r.at(f.first) != f.second) { match = false; break; }

&nbsp;       if (match) printRecord(r, header);

&nbsp;   }

}



// Roll-up

void rollup(const vector<map<string, string>>\& data, const string\& groupField, const string\& numericField) {

&nbsp;   cout << "\\nRoll-Up by " << groupField << " (sum of " << numericField << ")\\n";

&nbsp;   map<string, double> totals;

&nbsp;   for (const auto\& r : data) {

&nbsp;       try {

&nbsp;           double val = stod(r.at(numericField));

&nbsp;           totals\[r.at(groupField)] += val;

&nbsp;       } catch (...) {

&nbsp;           cout << "Column not numeric!\\n";

&nbsp;           return;

&nbsp;       }

&nbsp;   }

&nbsp;   for (auto\& t : totals)

&nbsp;       cout << t.first << " → " << t.second << endl;

}



// Drill-down

void drilldown(const vector<map<string, string>>\& data, const vector<string>\& header) {

&nbsp;   cout << "\\nDrill-down view:\\n";

&nbsp;   for (const auto\& r : data)

&nbsp;       printRecord(r, header);

}



// Pivot

void pivot(const vector<map<string, string>>\& data, const string\& rowField,

&nbsp;          const string\& colField, const string\& numericField) {

&nbsp;   cout << "\\nPivot (" << rowField << " vs " << colField << ")\\n";

&nbsp;   map<string, map<string, double>> pivot;

&nbsp;   set<string> colValues;



&nbsp;   for (const auto\& r : data) {

&nbsp;       try {

&nbsp;           double val = stod(r.at(numericField));

&nbsp;           string row = r.at(rowField);

&nbsp;           string col = r.at(colField);

&nbsp;           colValues.insert(col);

&nbsp;           pivot\[row]\[col] += val;

&nbsp;       } catch (...) {

&nbsp;           cout << "Column not numeric!\\n";

&nbsp;           return;

&nbsp;       }

&nbsp;   }



&nbsp;   cout << rowField << "\\t";

&nbsp;   for (const string\& col : colValues) cout << col << "\\t";

&nbsp;   cout << endl;



&nbsp;   for (const auto\& rowPair : pivot) {

&nbsp;       cout << rowPair.first << "\\t";

&nbsp;       for (const string\& col : colValues)

&nbsp;           cout << rowPair.second.at(col) << "\\t";

&nbsp;       cout << endl;

&nbsp;   }

}



int main() {

&nbsp;   string fileName;

&nbsp;   cout << "Enter CSV file name: ";

&nbsp;   getline(cin, fileName);



&nbsp;   vector<string> header;

&nbsp;   vector<map<string, string>> data = readCSV(fileName, header);



&nbsp;   if (data.empty()) {

&nbsp;       cout << "No data found!\\n";

&nbsp;       return 0;

&nbsp;   }



&nbsp;   cout << "\\nColumns: ";

&nbsp;   for (auto\& h : header) cout << h << " ";

&nbsp;   cout << endl;



&nbsp;   while (true) {

&nbsp;       cout << "\\n--- OLAP MENU ---\\n";

&nbsp;       cout << "1. Show Data\\n2. Slice\\n3. Dice\\n4. Roll-Up\\n5. Drill-Down\\n6. Pivot\\n0. Exit\\nChoice: ";

&nbsp;       int ch; cin >> ch; cin.ignore();



&nbsp;       if (ch == 1) {

&nbsp;           for (auto\& r : data) printRecord(r, header);



&nbsp;       } else if (ch == 2) {

&nbsp;           string field, value;

&nbsp;           cout << "Field: "; getline(cin, field);

&nbsp;           cout << "Value: "; getline(cin, value);

&nbsp;           sliceData(data, field, value, header);  // ✅ renamed



&nbsp;       } else if (ch == 3) {

&nbsp;           int n;

&nbsp;           cout << "How many filters? "; cin >> n; cin.ignore();

&nbsp;           map<string, string> filters;

&nbsp;           for (int i = 0; i < n; i++) {

&nbsp;               string f, v;

&nbsp;               cout << "Field: "; getline(cin, f);

&nbsp;               cout << "Value: "; getline(cin, v);

&nbsp;               filters\[f] = v;

&nbsp;           }

&nbsp;           dice(data, filters, header);



&nbsp;       } else if (ch == 4) {

&nbsp;           string group, num;

&nbsp;           cout << "Group by field: "; getline(cin, group);

&nbsp;           cout << "Numeric field: "; getline(cin, num);

&nbsp;           rollup(data, group, num);



&nbsp;       } else if (ch == 5) {

&nbsp;           drilldown(data, header);



&nbsp;       } else if (ch == 6) {

&nbsp;           string row, col, num;

&nbsp;           cout << "Row field: "; getline(cin, row);

&nbsp;           cout << "Column field: "; getline(cin, col);

&nbsp;           cout << "Numeric field: "; getline(cin, num);

&nbsp;           pivot(data, row, col, num);



&nbsp;       } else if (ch == 0) {

&nbsp;           cout << "Goodbye!\\n";

&nbsp;           break;

&nbsp;       } else {

&nbsp;           cout << "Invalid choice!\\n";

&nbsp;       }

&nbsp;   }

&nbsp;   return 0;

}

Name,Department,IQ,Prev\_Sem\_Result,CGPA,Academic\_Performance,Extra\_Curricular\_Score,Communication\_Skills,Projects\_Completed

Amit,IT,120,85,8.2,90,80,75,4

Riya,CS,110,88,8.5,85,70,80,5

Kabir,IT,130,82,8.0,88,60,70,3

Sneha,ENTC,115,79,7.5,83,90,78,4

Aryan,CS,125,91,9.0,92,85,88,6

Neha,IT,118,87,8.1,86,75,76,4





#### **3.tweight dweight**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

using namespace std;



struct Row {

&nbsp;   string class\_name;

&nbsp;   int cat1;

&nbsp;   int cat2;

};



int main() {

&nbsp;   ifstream file("input.csv");

&nbsp;   if (!file) {

&nbsp;       cout << "File not found!\\n";

&nbsp;       return 1;

&nbsp;   }



&nbsp;   string line;

&nbsp;   vector<Row> data;

&nbsp;   int totalCat1 = 0, totalCat2 = 0;



&nbsp;   getline(file, line); // skip header line

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       string className, c1s, c2s;



&nbsp;       getline(ss, className, ',');

&nbsp;       getline(ss, c1s, ',');

&nbsp;       getline(ss, c2s, ',');



&nbsp;       int cat1 = stoi(c1s);

&nbsp;       int cat2 = stoi(c2s);



&nbsp;       Row r;

&nbsp;       r.class\_name = className;

&nbsp;       r.cat1 = cat1;

&nbsp;       r.cat2 = cat2;

&nbsp;       data.push\_back(r);



&nbsp;       totalCat1 += cat1;

&nbsp;       totalCat2 += cat2;

&nbsp;   }

&nbsp;   file.close();



&nbsp;   ofstream out("twt\_dwt\_output.csv");

&nbsp;   out << "Class,Category1,Twt,Dwt,Category2,Twt,Dwt,Total\\n";



&nbsp;   cout << "\\nTwt and Dwt Results:\\n\\n";

&nbsp;   cout << "Class         Cat1   Twt%   Dwt%   Cat2   Twt%   Dwt%   Total\\n";



&nbsp;   for (int i = 0; i < data.size(); i++) {

&nbsp;       string name = data\[i].class\_name;

&nbsp;       int cat1 = data\[i].cat1;

&nbsp;       int cat2 = data\[i].cat2;

&nbsp;       int total = cat1 + cat2;



&nbsp;       double cat1Twt = (cat1 \* 100.0) / total;

&nbsp;       double cat1Dwt = (cat1 \* 100.0) / totalCat1;

&nbsp;       double cat2Twt = (cat2 \* 100.0) / total;

&nbsp;       double cat2Dwt = (cat2 \* 100.0) / totalCat2;



&nbsp;       cout << name << "   " << cat1 << "   " << cat1Twt << "   " << cat1Dwt

&nbsp;            << "   " << cat2 << "   " << cat2Twt << "   " << cat2Dwt

&nbsp;            << "   " << total << endl;



&nbsp;       out << name << "," << cat1 << "," << cat1Twt << "%," << cat1Dwt << "%,"

&nbsp;           << cat2 << "," << cat2Twt << "%," << cat2Dwt << "%," << total << "\\n";

&nbsp;   }



&nbsp;   cout << "Total         " << totalCat1 << "   100   100   " << totalCat2

&nbsp;        << "   100   100   " << totalCat1 + totalCat2 << endl;



&nbsp;   out << "Total," << totalCat1 << ",100%,100%," << totalCat2

&nbsp;       << ",100%,100%," << totalCat1 + totalCat2 << "\\n";



&nbsp;   out.close();



&nbsp;   cout << "\\nSaved to twt\_dwt\_output.csv\\n";

&nbsp;   return 0;

}

Location,TV,Computer

Europe,80,240

North America,120,560







#### **4.Boxplot**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <string>

\#include <climits>

\#include <iomanip>

\#include <cmath>

\#include <algorithm>

using namespace std;



vector<double> read\_csv(string \&filename) {

&nbsp;   ifstream file(filename);

&nbsp;   vector<double> data;

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error opening file!" << endl;

&nbsp;       return data;

&nbsp;   }



&nbsp;   string line, header;

&nbsp;   getline(file, header); // skip header



&nbsp;   while (getline(file, line)) {

&nbsp;       if (!line.empty())

&nbsp;           data.push\_back(stod(line));

&nbsp;   }



&nbsp;   file.close();

&nbsp;   return data;

}



double median(vector<double> \&data) {

&nbsp;   int n = data.size();

&nbsp;   if (n == 0) return 0;

&nbsp;   if (n % 2 == 0)

&nbsp;       return (data\[n / 2 - 1] + data\[n / 2]) / 2.0;

&nbsp;   else

&nbsp;       return data\[n / 2];

}



int main() {

&nbsp;   string filename = "data.csv";

&nbsp;   vector<double> data = read\_csv(filename);



&nbsp;   if (data.empty()) {

&nbsp;       cout << "No data found!" << endl;

&nbsp;       return 0;

&nbsp;   }



&nbsp;   sort(data.begin(), data.end());

&nbsp;   int n = data.size();



&nbsp;   double Q2 = median(data);



&nbsp;   vector<double> lower\_half, upper\_half;

&nbsp;   int mid = n / 2;



&nbsp;   if (n % 2 == 0) {

&nbsp;       lower\_half = vector<double>(data.begin(), data.begin() + mid);

&nbsp;       upper\_half = vector<double>(data.begin() + mid, data.end());

&nbsp;   } else {

&nbsp;       lower\_half = vector<double>(data.begin(), data.begin() + mid);

&nbsp;       upper\_half = vector<double>(data.begin() + mid + 1, data.end());

&nbsp;   }



&nbsp;   double Q1 = median(lower\_half);

&nbsp;   double Q3 = median(upper\_half);

&nbsp;   double IQR = Q3 - Q1;



&nbsp;   double lower\_bound = Q1 - 1.5 \* IQR;

&nbsp;   double upper\_bound = Q3 + 1.5 \* IQR;



&nbsp;   double minVal = data\[0], maxVal = data\[n - 1];



&nbsp;   cout << "\\n--- Outliers ---\\n";

&nbsp;   for (double val : data) {

&nbsp;       if (val < lower\_bound || val > upper\_bound)

&nbsp;           cout << val << " ";

&nbsp;   }

&nbsp;   cout << "\\n";



&nbsp;   // Update min/max excluding outliers

&nbsp;   for (double val : data) {

&nbsp;       if (val >= lower\_bound) {

&nbsp;           minVal = val;

&nbsp;           break;

&nbsp;       }

&nbsp;   }

&nbsp;   for (int i = n - 1; i >= 0; i--) {

&nbsp;       if (data\[i] <= upper\_bound) {

&nbsp;           maxVal = data\[i];

&nbsp;           break;

&nbsp;       }

&nbsp;   }



&nbsp;   cout << fixed << setprecision(2);

&nbsp;   cout << "\\nFive Number Summary:\\n";

&nbsp;   cout << "Min: " << minVal << endl;

&nbsp;   cout << "Q1 : " << Q1 << endl;

&nbsp;   cout << "Q2 : " << Q2 << endl;

&nbsp;   cout << "Q3 : " << Q3 << endl;

&nbsp;   cout << "Max: " << maxVal << endl;



&nbsp;   return 0;

}



Math

14

16

18

12

13

17

15

19

35

20





#### **Apriori:**

\#include <bits/stdc++.h>

using namespace std;



// Function to calculate support count of an itemset

int getSupportCount(const set<string> \&itemset, const vector<set<string>> \&transactions) {

&nbsp;   int count = 0;

&nbsp;   for (auto \&transaction : transactions) {

&nbsp;       if (includes(transaction.begin(), transaction.end(), itemset.begin(), itemset.end()))

&nbsp;           count++;

&nbsp;   }

&nbsp;   return count;

}



// Helper function to print a set nicely

void printSet(const set<string> \&s) {

&nbsp;   int idx = 0;

&nbsp;   cout << "{";

&nbsp;   for (auto \&item : s) {

&nbsp;       if (idx++) cout << ",";

&nbsp;       cout << item;

&nbsp;   }

&nbsp;   cout << "}";

}



// Generate all non-empty proper subsets of an itemset

vector<set<string>> getSubsets(const set<string> \&itemset) {

&nbsp;   vector<string> items(itemset.begin(), itemset.end());

&nbsp;   int n = items.size();

&nbsp;   vector<set<string>> subsets;



&nbsp;   for (int size = 1; size < n; ++size) {

&nbsp;       vector<bool> select(n, false);

&nbsp;       fill(select.begin(), select.begin() + size, true);



&nbsp;       do {

&nbsp;           set<string> subset;

&nbsp;           for (int i = 0; i < n; ++i) {

&nbsp;               if (select\[i]) subset.insert(items\[i]);

&nbsp;           }

&nbsp;           subsets.push\_back(subset);

&nbsp;       } while (prev\_permutation(select.begin(), select.end()));

&nbsp;   }



&nbsp;   return subsets;

}



int main() {

&nbsp;   // --- Read transactions from CSV ---

&nbsp;   ifstream file("transactions.csv");

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error: Could not open transactions.csv\\n";

&nbsp;       return 0;

&nbsp;   }



&nbsp;   vector<set<string>> transactions;

&nbsp;   string line;

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       string item;

&nbsp;       set<string> transaction;

&nbsp;       while (getline(ss, item, ',')) {

&nbsp;           if (!item.empty())

&nbsp;               transaction.insert(item);

&nbsp;       }

&nbsp;       if (!transaction.empty())

&nbsp;           transactions.push\_back(transaction);

&nbsp;   }

&nbsp;   file.close();



&nbsp;   // --- Input minimum support and confidence ---

&nbsp;   double minSupportInput, minConfidence;

&nbsp;   cout << "Enter minimum support (0-1): ";

&nbsp;   cin >> minSupportInput;

&nbsp;   cout << "Enter minimum confidence (0-1): ";

&nbsp;   cin >> minConfidence;



&nbsp;   int minCount = ceil(minSupportInput \* transactions.size());

&nbsp;   map<int, map<set<string>, int>> frequentItemsets;



&nbsp;   // --- Step 1: Count all 1-itemsets ---

&nbsp;   for (auto \&transaction : transactions) {

&nbsp;       for (auto \&item : transaction)

&nbsp;           frequentItemsets\[1]\[{item}]++;

&nbsp;   }



&nbsp;   // Remove 1-itemsets below min support

&nbsp;   for (auto it = frequentItemsets\[1].begin(); it != frequentItemsets\[1].end();) {

&nbsp;       if (it->second < minCount)

&nbsp;           it = frequentItemsets\[1].erase(it);

&nbsp;       else

&nbsp;           ++it;

&nbsp;   }



&nbsp;   // --- Step 2: Generate k-itemsets (k>=2) ---

&nbsp;   int k = 2;

&nbsp;   while (!frequentItemsets\[k-1].empty()) {

&nbsp;       vector<set<string>> prevLevel;

&nbsp;       for (auto \&p : frequentItemsets\[k-1])

&nbsp;           prevLevel.push\_back(p.first);



&nbsp;       for (int i = 0; i < prevLevel.size(); ++i) {

&nbsp;           for (int j = i + 1; j < prevLevel.size(); ++j) {

&nbsp;               set<string> candidate = prevLevel\[i];

&nbsp;               candidate.insert(prevLevel\[j].begin(), prevLevel\[j].end());



&nbsp;               if (candidate.size() == k) {

&nbsp;                   int supportCount = getSupportCount(candidate, transactions);

&nbsp;                   if (supportCount >= minCount)

&nbsp;                       frequentItemsets\[k]\[candidate] = supportCount;

&nbsp;               }

&nbsp;           }

&nbsp;       }

&nbsp;       k++;

&nbsp;   }



&nbsp;   // --- Step 3: Print all frequent itemsets (support >= minSupport) ---

&nbsp;   cout << "\\n=== Frequent Itemsets (support >= " << minSupportInput << ") ===\\n";

&nbsp;   for (auto \&level : frequentItemsets) {

&nbsp;       if (level.second.empty()) continue;

&nbsp;       for (auto \&p : level.second) {

&nbsp;           printSet(p.first);

&nbsp;           cout << " -> support=" << round((double)p.second / transactions.size()\*100.0)/100.0 << endl;

&nbsp;       }

&nbsp;   }



&nbsp;   // --- Step 4: Generate Association Rules satisfying minConfidence ---

&nbsp;   cout << "\\n=== Association Rules (minConfidence = " << minConfidence << ") ===\\n";

&nbsp;   for (auto \&level : frequentItemsets) {

&nbsp;       if (level.first < 2) continue;



&nbsp;       for (auto \&entry : level.second) {

&nbsp;           const set<string> \&itemset = entry.first;

&nbsp;           int itemsetSupport = entry.second;



&nbsp;           auto subsets = getSubsets(itemset);

&nbsp;           for (auto \&A : subsets) {

&nbsp;               set<string> B;

&nbsp;               for (auto \&item : itemset)

&nbsp;                   if (A.find(item) == A.end()) B.insert(item);



&nbsp;               double confidence = (double)itemsetSupport / getSupportCount(A, transactions);

&nbsp;               if (confidence >= minConfidence) {

&nbsp;                   printSet(A);

&nbsp;                   cout << " => ";

&nbsp;                   printSet(B);

&nbsp;                   cout << " (conf=" << round(confidence\*100.0)/100.0

&nbsp;                        << ", support=" << round((double)itemsetSupport/transactions.size()\*100.0)/100.0 << ")\\n";

&nbsp;               }

&nbsp;           }

&nbsp;       }

&nbsp;   }



&nbsp;   return 0;

}

Milk,Bread,Butter

Bread,Egg

Milk,Butter,Egg

Milk,Bread,Egg

Bread,Butter

Milk,Butter





#### **7.apriori**



\#include<bits/stdc++.h>

using namespace std;



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   string line;

&nbsp;   vector<vector<double>> data;



&nbsp;   // Read CSV data

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       string val;

&nbsp;       vector<double> row;

&nbsp;       while (getline(ss, val, ',')) {

&nbsp;           row.push\_back(stod(val));

&nbsp;       }

&nbsp;       if (!row.empty()) data.push\_back(row);

&nbsp;   }

&nbsp;   file.close();



&nbsp;   int n = data.size();

&nbsp;   int m = data\[0].size();



&nbsp;   // Compute correlation for each pair of columns

&nbsp;   for (int i = 0; i < m; i++) {

&nbsp;       for (int j = i + 1; j < m; j++) {

&nbsp;           double sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0, sumy2 = 0;



&nbsp;           for (int k = 0; k < n; k++) {

&nbsp;               double x = data\[k]\[i];

&nbsp;               double y = data\[k]\[j];

&nbsp;               sumx += x;

&nbsp;               sumy += y;

&nbsp;               sumxy += x \* y;

&nbsp;               sumx2 += x \* x;

&nbsp;               sumy2 += y \* y;

&nbsp;           }



&nbsp;           double num = (n \* sumxy) - (sumx \* sumy);

&nbsp;           double den = sqrt((n \* sumx2 - sumx \* sumx) \* (n \* sumy2 - sumy \* sumy));



&nbsp;           double corr = (den != 0) ? num / den : 0;



&nbsp;           cout << "Correlation between column " << i + 1

&nbsp;                << " and column " << j + 1 << " = " << corr << endl;

&nbsp;       }

&nbsp;   }



&nbsp;   return 0;

}

2.5,3.6,4.1,10.2

3.1,4.0,5.0,12.3

4.0,5.2,6.1,14.4

4.8,5.9,6.8,15.0

5.2,6.3,7.5,16.8

6.0,7.1,8.0,18.2

6.5,7.4,8.6,19.5

7.2,8.0,9.1,20.3

8.0,8.8,9.8,22.1

8.5,9.2,10.3,23.5





#### **8.k-means**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <cmath>

\#include <limits>



using namespace std;



double euclideanDistance(const vector<double> \&a, const vector<double> \&b) {

&nbsp;   double sum = 0.0;

&nbsp;   for (int i = 0; i < a.size(); i++)

&nbsp;       sum += pow(a\[i] - b\[i], 2);

&nbsp;   return sqrt(sum);

}



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   string header;

&nbsp;   getline(file, header); 



&nbsp;   vector<vector<double>> data;

&nbsp;   string line;

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       string value;

&nbsp;       vector<double> row;

&nbsp;       while (getline(ss, value, ',')) {

&nbsp;           if (!value.empty())

&nbsp;               row.push\_back(stod(value));

&nbsp;       }

&nbsp;       if (!row.empty())

&nbsp;           data.push\_back(row);

&nbsp;   }

&nbsp;   file.close();



&nbsp;   int n = data.size();

&nbsp;   int dim = data\[0].size();

&nbsp;   cout << "Data loaded: " << n << " points, " << dim << " dimensions.\\n";



&nbsp;   int k;

&nbsp;   cout << "Enter number of clusters: ";

&nbsp;   cin >> k;



&nbsp;   vector<vector<double>> centroids(k, vector<double>(dim));

&nbsp;   vector<vector<double>> centroidSum(k, vector<double>(dim));

&nbsp;   vector<int> count(k, 0);

&nbsp;   vector<int> label(n, -1);



&nbsp;   for (int i = 0; i < k; i++)

&nbsp;       centroids\[i] = data\[i];



&nbsp;   bool changed = true;

&nbsp;   int step = 0;

&nbsp;   while (changed \&\& step < 100) {

&nbsp;       changed = false;

&nbsp;       step++;

&nbsp;       cout << "\\n--- Step " << step << " ---\\n";



&nbsp;       // Reset sums and counts

&nbsp;       for (int i = 0; i < k; i++) {

&nbsp;           count\[i] = 0;

&nbsp;           fill(centroidSum\[i].begin(), centroidSum\[i].end(), 0.0);

&nbsp;       }



&nbsp;       // Assign points to nearest centroid

&nbsp;       for (int i = 0; i < n; i++) {

&nbsp;           double minDist = INT\_MAX;

&nbsp;           int best = -1;



&nbsp;           for (int c = 0; c < k; c++) {

&nbsp;               double dist = euclideanDistance(data\[i], centroids\[c]);

&nbsp;               if (dist < minDist) {

&nbsp;                   minDist = dist;

&nbsp;                   best = c;

&nbsp;               }

&nbsp;           }



&nbsp;           if (label\[i] != best)

&nbsp;               changed = true;



&nbsp;           label\[i] = best;



&nbsp;           // Add point to centroid sum

&nbsp;           for (int d = 0; d < dim; d++)

&nbsp;               centroidSum\[best]\[d] += data\[i]\[d];



&nbsp;           count\[best]++;

&nbsp;       }



&nbsp;       // Update centroids

&nbsp;       for (int c = 0; c < k; c++) {

&nbsp;           if (count\[c] > 0) {

&nbsp;               for (int d = 0; d < dim; d++)

&nbsp;                   centroids\[c]\[d] = centroidSum\[c]\[d] / count\[c];

&nbsp;           }

&nbsp;       }



&nbsp;       // --- Print current centroids and cluster points ---

&nbsp;       for (int c = 0; c < k; c++) {

&nbsp;           cout << "Cluster " << c + 1 << " centroid: ";

&nbsp;           for (int d = 0; d < dim; d++)

&nbsp;               cout << centroids\[c]\[d] << " ";

&nbsp;           cout << "\\nPoints: ";

&nbsp;           for (int i = 0; i < n; i++)

&nbsp;               if (label\[i] == c)

&nbsp;                   cout << "P" << i + 1 << " ";

&nbsp;           cout << "\\n";

&nbsp;       }

&nbsp;   }



&nbsp;   cout << "\\nK-means clustering completed in " << step << " steps!\\n";



&nbsp;   return 0;

}



X,Y

1.0,2.0

1.5,1.8

5.0,8.0

8.0,8.0

1.0,0.6

9.0,11.0

8.0,2.0

10.0,2.0

9.0,3.0







#### **9.hierarchical**

1.single

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double, double> a, pair<double, double> b) {

&nbsp;   return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   vector<pair<double, double>> points;

&nbsp;   double x, y;

&nbsp;   char comma;

&nbsp;   while(file >> x >> comma >> y)

&nbsp;       points.push\_back({x, y});

&nbsp;   file.close();



&nbsp;   int n = points.size();



&nbsp;   // Initialize clusters: each cluster stores indices of points

&nbsp;   vector<vector<int>> clusters;

&nbsp;   for(int i = 0; i < n; i++)

&nbsp;       clusters.push\_back({i});



&nbsp;   // Print initial clusters

&nbsp;   cout << "Initial clusters:\\n";

&nbsp;   for(int i = 0; i < n; i++) 

&nbsp;       cout << "P" << i+1 << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while(clusters.size() > 1) {

&nbsp;       double minDist = INT\_MAX;

&nbsp;       int idxA = -1, idxB = -1;



&nbsp;       // Find closest pair of clusters (single linkage)

&nbsp;       for(int i = 0; i < clusters.size(); i++) {

&nbsp;           for(int j = i+1; j < clusters.size(); j++) {

&nbsp;               double d = 1e9;

&nbsp;               for(int p1 : clusters\[i])

&nbsp;                   for(int p2 : clusters\[j])

&nbsp;                       d = min(d, euclideanDistance(points\[p1], points\[p2]));

&nbsp;               if(d < minDist) {

&nbsp;                   minDist = d;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());



&nbsp;       // Print merge info

&nbsp;       cout << "Merging clusters: ";

&nbsp;       for(int p : clusters\[idxA]) cout << "P" << p+1 << " ";

&nbsp;       cout << "and ";

&nbsp;       for(int p : clusters\[idxB]) cout << "P" << p+1 << " ";

&nbsp;       cout << "(distance = " << minDist << ")\\n";



&nbsp;       // Remove old clusters and add merged

&nbsp;       if(idxA < idxB) { 

&nbsp;           clusters.erase(clusters.begin() + idxB); 

&nbsp;           clusters.erase(clusters.begin() + idxA); 

&nbsp;       }

&nbsp;       else { clusters.erase(clusters.begin() + idxA); 

&nbsp;           clusters.erase(clusters.begin() + idxB); 

&nbsp;       }

&nbsp;       clusters.push\_back(merged);

&nbsp;   }



&nbsp;   // Print final cluster

&nbsp;   cout << "\\nFinal Cluster: ";

&nbsp;   for(int p : clusters\[0]) cout << "P" << p+1 << " ";

&nbsp;   cout << "\\n";



&nbsp;   return 0;

}



2.complete

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double,double> a, pair<double,double> b) {

&nbsp;   return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   vector<pair<double,double>> points;

&nbsp;   double x, y;

&nbsp;   char comma;

&nbsp;   while(file >> x >> comma >> y)

&nbsp;       points.push\_back({x,y});

&nbsp;   file.close();



&nbsp;   int n = points.size();



&nbsp;   // Each cluster stores the indices of points

&nbsp;   vector<vector<int>> clusters;

&nbsp;   vector<string> clusterNames;

&nbsp;   for(int i = 0; i < n; i++) {

&nbsp;       clusters.push\_back({i});

&nbsp;       clusterNames.push\_back("P" + to\_string(i+1));

&nbsp;   }



&nbsp;   cout << "Initial clusters:\\n";

&nbsp;   for(auto \&name : clusterNames) cout << name << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while(clusters.size() > 1) {

&nbsp;       double minDist = 1e9;

&nbsp;       int idxA=-1, idxB=-1;



&nbsp;       // Find closest pair of clusters (complete linkage)

&nbsp;       for(int i = 0; i < clusters.size(); i++) {

&nbsp;           for(int j = i+1; j < clusters.size(); j++) {

&nbsp;               double d = 0; // complete linkage → max distance

&nbsp;               for(int p1 : clusters\[i])

&nbsp;                   for(int p2 : clusters\[j])

&nbsp;                       d = max(d, euclideanDistance(points\[p1], points\[p2]));

&nbsp;               if(d < minDist) {

&nbsp;                   minDist = d;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());

&nbsp;       string mergedName = "(" + clusterNames\[idxA] + "," + clusterNames\[idxB] + ")";



&nbsp;       // Print merge info

&nbsp;       cout << "Merging " << clusterNames\[idxA] << " and " << clusterNames\[idxB]

&nbsp;            << " => " << mergedName << " (distance = " << minDist << ")\\n";



&nbsp;       // Remove old clusters and add merged

&nbsp;       if(idxA < idxB) {

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxB);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxA);

&nbsp;       } else {

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxA);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxB);

&nbsp;       }



&nbsp;       clusters.push\_back(merged);

&nbsp;       clusterNames.push\_back(mergedName);

&nbsp;   }



&nbsp;   cout << "\\nFinal Cluster: " << clusterNames\[0] << "\\n";

&nbsp;   return 0;

}



3.average

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double,double> a, pair<double,double> b) {

&nbsp;   return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   vector<pair<double,double>> points;

&nbsp;   double x, y;

&nbsp;   char comma;

&nbsp;   while(file >> x >> comma >> y)

&nbsp;       points.push\_back({x,y});

&nbsp;   file.close();



&nbsp;   int n = points.size();



&nbsp;   // Each cluster stores the indices of points

&nbsp;   vector<vector<int>> clusters;

&nbsp;   vector<string> clusterNames;

&nbsp;   for(int i = 0; i < n; i++) {

&nbsp;       clusters.push\_back({i});

&nbsp;       clusterNames.push\_back("P" + to\_string(i+1));

&nbsp;   }



&nbsp;   cout << "Initial clusters:\\n";

&nbsp;   for(auto \&name : clusterNames) cout << name << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while(clusters.size() > 1) {

&nbsp;       double minDist = 1e9;

&nbsp;       int idxA=-1, idxB=-1;



&nbsp;       // Find closest pair of clusters (average linkage)

&nbsp;       for(int i = 0; i < clusters.size(); i++) {

&nbsp;           for(int j = i+1; j < clusters.size(); j++) {

&nbsp;               double sumDist = 0;

&nbsp;               int count = 0;

&nbsp;               for(int p1 : clusters\[i]) {

&nbsp;                   for(int p2 : clusters\[j]) {

&nbsp;                       sumDist += euclideanDistance(points\[p1], points\[p2]);

&nbsp;                       count++;

&nbsp;                   }

&nbsp;               }

&nbsp;               double avgDist = sumDist / count; // average distance

&nbsp;               if(avgDist < minDist) {

&nbsp;                   minDist = avgDist;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());

&nbsp;       string mergedName = "(" + clusterNames\[idxA] + "," + clusterNames\[idxB] + ")";



&nbsp;       // Print merge info

&nbsp;       cout << "Merging " << clusterNames\[idxA] << " and " << clusterNames\[idxB]

&nbsp;            << " => " << mergedName << " (distance = " << minDist << ")\\n";



&nbsp;       // Remove old clusters and add merged

&nbsp;       if(idxA < idxB) {

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxB);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxA);

&nbsp;       } else {

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxA);

&nbsp;           clusterNames.erase(clusterNames.begin() + idxB);

&nbsp;       }



&nbsp;       clusters.push\_back(merged);

&nbsp;       clusterNames.push\_back(mergedName);

&nbsp;   }



&nbsp;   cout << "\\nFinal Cluster: " << clusterNames\[0] << "\\n";

&nbsp;   return 0;

}



1,1

1.2,1.1

2.1,6

5.8,9

8,8

8.2,8.1



#### **10.DBSCAN**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <cmath>

using namespace std;



struct Point {

&nbsp;   vector<double> coords; // store all dimensions

&nbsp;   int cluster;

};





double distance(const Point \&a, const Point \&b) {

&nbsp;   double sum = 0.0;

&nbsp;   for (size\_t i = 0; i < a.coords.size(); i++) {

&nbsp;       sum += pow(a.coords\[i] - b.coords\[i], 2);

&nbsp;   }

&nbsp;   return sqrt(sum);

}





vector<int> getNeighbors(const vector<Point> \&points, int idx, double eps) {

&nbsp;   vector<int> neighbors;

&nbsp;   for (int i = 0; i < points.size(); i++) {

&nbsp;       if (distance(points\[idx], points\[i]) <= eps)

&nbsp;           neighbors.push\_back(i);

&nbsp;   }

&nbsp;   return neighbors;

}



void expandCluster(vector<Point> \&points, int idx, vector<int> neighbors,

&nbsp;                  int clusterId, double eps, int minPts) {

&nbsp;   points\[idx].cluster = clusterId;



&nbsp;   for (int i = 0; i < neighbors.size(); i++) {

&nbsp;       int nIdx = neighbors\[i];



&nbsp;       if (points\[nIdx].cluster == 0) { // unvisited

&nbsp;           points\[nIdx].cluster = clusterId;

&nbsp;           vector<int> newNeighbors = getNeighbors(points, nIdx, eps);



&nbsp;           if (newNeighbors.size() >= minPts)

&nbsp;               neighbors.insert(neighbors.end(), newNeighbors.begin(), newNeighbors.end());

&nbsp;       }



&nbsp;       if (points\[nIdx].cluster == -1) // was noise

&nbsp;           points\[nIdx].cluster = clusterId;

&nbsp;   }

}



int main() {

&nbsp;  ifstream file("data.csv");

vector<Point> points;

string line;



while (getline(file, line)) {

&nbsp;   stringstream ss(line);

&nbsp;   string value;

&nbsp;   Point p;

&nbsp;   while (getline(ss, value, ',')) {

&nbsp;       p.coords.push\_back(stod(value)); // add each dimension

&nbsp;   }

&nbsp;   p.cluster = 0;

&nbsp;   points.push\_back(p);

}

&nbsp;   double eps;

&nbsp;   int minPts;

&nbsp;   cout << "Enter eps and minPts: ";

&nbsp;   cin >> eps >> minPts;



&nbsp;   int clusterId = 0;



&nbsp;   for (int i = 0; i < points.size(); i++) {

&nbsp;       if (points\[i].cluster != 0) continue; 

&nbsp;       

&nbsp;       vector<int> neighbors = getNeighbors(points, i, eps);



&nbsp;       if (neighbors.size() < minPts) {

&nbsp;           points\[i].cluster = -1; // mark as noise

&nbsp;       } else {

&nbsp;           clusterId++;

&nbsp;           expandCluster(points, i, neighbors, clusterId, eps, minPts);

&nbsp;       }

&nbsp;   }



&nbsp;   cout << "\\n=== DBSCAN Clustering Result ===\\n";

for (int i = 0; i < points.size(); i++) {

&nbsp;   cout << "(";

&nbsp;   for (int j = 0; j < points\[i].coords.size(); j++) {

&nbsp;       cout << points\[i].coords\[j];

&nbsp;       if (j != points\[i].coords.size() - 1)

&nbsp;           cout << ", ";

&nbsp;   }

&nbsp;   cout << ") -> ";

&nbsp;   

&nbsp;   if (points\[i].cluster == -1)

&nbsp;       cout << "Noise\\n";

&nbsp;   else

&nbsp;       cout << "Cluster " << points\[i].cluster << "\\n";

}



&nbsp;   return 0;

}





1,1,1

1.1,1.2,0.9

8,8,8

8.2,8.1,7.9

0,0,0



#### **12.linear regression**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <iomanip>

using namespace std;



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   vector<double> dataX, dataY;

&nbsp;   string header;

&nbsp;   getline(file, header); // skip header



&nbsp;   string line;

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       string valX, valY;

&nbsp;       if (!getline(ss, valX, ',') || !getline(ss, valY, ',')) continue;

&nbsp;       dataX.push\_back(stod(valX));

&nbsp;       dataY.push\_back(stod(valY));

&nbsp;   }

&nbsp;   file.close();



&nbsp;   int n = dataX.size();

&nbsp;   if (n == 0) {

&nbsp;       cout << "No data found!" << endl;

&nbsp;       return 0;

&nbsp;   }



&nbsp;   // Step 1: Calculate sums

&nbsp;   double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

&nbsp;   for (int i = 0; i < n; i++) {

&nbsp;       sumX += dataX\[i];

&nbsp;       sumY += dataY\[i];

&nbsp;       sumXY += dataX\[i] \* dataY\[i];

&nbsp;       sumX2 += dataX\[i] \* dataX\[i];

&nbsp;   }



&nbsp;   cout << fixed << setprecision(4);

&nbsp;   cout << "\\nStep 1: Calculate sums\\n";

&nbsp;   cout << "Sum of X: " << sumX << endl;

&nbsp;   cout << "Sum of Y: " << sumY << endl;

&nbsp;   cout << "Sum of X\*Y: " << sumXY << endl;

&nbsp;   cout << "Sum of X^2: " << sumX2 << endl;



&nbsp;   // Step 2: Calculate slope (m)

&nbsp;   double slope = ((n \* sumXY) - (sumX \* sumY)) / ((n \* sumX2) - (sumX \* sumX));

&nbsp;   cout << "\\nStep 2: Calculate slope (m)\\n";

&nbsp;   cout << "Slope (m) = " << slope << endl;



&nbsp;   // Step 3: Calculate intercept (b)

&nbsp;   double intercept = (sumY - slope \* sumX) / n;

&nbsp;   cout << "\\nStep 3: Calculate intercept (b)\\n";

&nbsp;   cout << "Intercept (b) = " << intercept << endl;



&nbsp;   // Step 4: Make prediction

&nbsp;   double xInput;

&nbsp;   cout << "\\nStep 4: Predict Y for a given X\\n";

&nbsp;   cout << "Enter X value: ";

&nbsp;   cin >> xInput;

&nbsp;   double yPred = intercept + slope \* xInput;

&nbsp;   cout << "Predicted Y = " << yPred << endl;



&nbsp;   return 0;

}

X,Y

1,2

2,3

3,4

4,5

5,7



#### **13.bayes**



\#include<bits/stdc++.h>

using namespace std;



int main() {

&nbsp;   // --- Step 1: Read CSV file ---

&nbsp;   ifstream file("data.csv");

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error: Unable to open data.csv!" << endl;

&nbsp;       return 0;

&nbsp;   }



&nbsp;   string line;

&nbsp;   getline(file, line); // header

&nbsp;   stringstream header(line);

&nbsp;   vector<string> headers;

&nbsp;   string col;

&nbsp;   while (getline(header, col, ',')) headers.push\_back(col);



&nbsp;   int nAttr = headers.size() - 1;    // last column is class

&nbsp;   string classCol = headers.back();



&nbsp;   vector<vector<string>> data;

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream ss(line);

&nbsp;       vector<string> row;

&nbsp;       string value;

&nbsp;       while (getline(ss, value, ',')) row.push\_back(value);

&nbsp;       if (!row.empty()) data.push\_back(row);

&nbsp;   }

&nbsp;   file.close();



&nbsp;   int totalRecords = data.size();



&nbsp;   // --- Step 2: Identify all possible classes ---

&nbsp;   vector<string> classes;

&nbsp;   for (auto \&row : data) {

&nbsp;       string cls = row\[nAttr];

&nbsp;       if (find(classes.begin(), classes.end(), cls) == classes.end())

&nbsp;           classes.push\_back(cls);

&nbsp;   }



&nbsp;   // --- Step 3: Input new record ---

&nbsp;   vector<string> newRecord(nAttr);

&nbsp;   cout << "\\nEnter new record values:\\n";

&nbsp;   for (int i = 0; i < nAttr; i++) {

&nbsp;       cout << headers\[i] << ": ";

&nbsp;       cin >> newRecord\[i];

&nbsp;   }



&nbsp;   // --- Step 4: Compute posterior probabilities ---

&nbsp;   vector<double> posterior(classes.size(), 0.0);

&nbsp;   cout << fixed << setprecision(4);



&nbsp;   cout << "\\n--- Step-by-step Posterior Probabilities ---\\n";

&nbsp;   for (int c = 0; c < classes.size(); c++) {

&nbsp;       string classVal = classes\[c];

&nbsp;       int classCount = 0;



&nbsp;       // Count how many records belong to this class

&nbsp;       for (auto \&row : data)

&nbsp;           if (row\[nAttr] == classVal)

&nbsp;               classCount++;



&nbsp;       double prior = (double)classCount / totalRecords;

&nbsp;       double prob = prior;



&nbsp;       cout << "\\nClass '" << classVal << "':\\n";

&nbsp;       cout << "Prior Probability P(" << classVal << ") = " << prior << endl;



&nbsp;       // Multiply conditional probabilities for each attribute

&nbsp;       for (int j = 0; j < nAttr; j++) {

&nbsp;           int match = 0;

&nbsp;           for (auto \&row : data) {

&nbsp;               if (row\[nAttr] == classVal \&\& row\[j] == newRecord\[j])

&nbsp;                   match++;

&nbsp;           }



&nbsp;           double condProb = 0.0;

&nbsp;           if (classCount > 0)

&nbsp;               condProb = (double)match / classCount;



&nbsp;           cout << "P(" << headers\[j] << "=" << newRecord\[j] 

&nbsp;                << " | " << classVal << ") = " << condProb << endl;



&nbsp;           prob \*= condProb;

&nbsp;       }



&nbsp;       posterior\[c] = prob;

&nbsp;       cout << "Posterior Probability for class " << classVal 

&nbsp;            << " = " << prob << endl;

&nbsp;   }



&nbsp;   // --- Step 5: Choose class with maximum posterior ---

&nbsp;   double maxProb = -1;

&nbsp;   string predicted;

&nbsp;   for (int c = 0; c < classes.size(); c++) {

&nbsp;       if (posterior\[c] > maxProb) {

&nbsp;           maxProb = posterior\[c];

&nbsp;           predicted = classes\[c];

&nbsp;       }

&nbsp;   }



&nbsp;   // --- Step 6: Display final prediction ---

&nbsp;   cout << "\\nPredicted Class: " << predicted << endl;

&nbsp;   cout << "\\n--- Conclusion ---\\n";

&nbsp;   cout << "The new record is most likely to belong to class '" 

&nbsp;        << predicted << "' based on Naive Bayes classification.\\n";



&nbsp;   return 0;

}

Outlook,Temperature,Humidity,Wind,Play

Sunny,Hot,High,Weak,No

Sunny,Hot,High,Strong,No

Overcast,Hot,High,Weak,Yes

Rain,Mild,High,Weak,Yes

Rain,Cool,Normal,Weak,Yes

Rain,Cool,Normal,Strong,No

Overcast,Cool,Normal,Strong,Yes

Sunny,Mild,High,Weak,No

Sunny,Cool,Normal,Weak,Yes

Rain,Mild,Normal,Weak,Yes

Sunny,Mild,Normal,Strong,Yes

Overcast,Mild,High,Strong,Yes

Overcast,Hot,Normal,Weak,Yes

Rain,Mild,High,Strong,No



