#### **Normalization:**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <string>

\#include <climits>

\#include <iomanip>

\#include <cmath>

using namespace std;



// ---------- Read CSV ----------

vector<vector<string>> read\_csv(string \&filename) {

    vector<vector<string>> data;

    ifstream file(filename);

    if (!file.is\_open()) {

        cout << "Error opening file!" << endl;

        return data;

    }



    string line;

    while (getline(file, line)) {

        vector<string> row;

        string cell;

        stringstream ss(line);

        while (getline(ss, cell, ',')) {

            row.push\_back(cell);

        }

        data.push\_back(row);

    }

    file.close();

    return data;

}



// ---------- Min-Max Normalization ----------

vector<vector<double>> minMaxNormalize(vector<vector<double>> \&data, double newMin, double newMax) {

    int rows = data.size();

    int cols = data\[0].size();



    vector<double> minVal(cols, INT\_MAX), maxVal(cols, INT\_MIN);



    for (int j = 0; j < cols; j++) {

        for (int i = 0; i < rows; i++) {

            if (data\[i]\[j] < minVal\[j]) minVal\[j] = data\[i]\[j];

            if (data\[i]\[j] > maxVal\[j]) maxVal\[j] = data\[i]\[j];

        }

    }



    vector<vector<double>> normalized(rows, vector<double>(cols, 0));

    for (int i = 0; i < rows; i++) {

        for (int j = 0; j < cols; j++) {

            if (maxVal\[j] != minVal\[j])

                normalized\[i]\[j] = (data\[i]\[j] - minVal\[j]) / (maxVal\[j] - minVal\[j]) \* (newMax - newMin) + newMin;

            else

                normalized\[i]\[j] = 0;

        }

    }

    return normalized;

}



// ---------- Z-Score Normalization ----------

vector<vector<double>> zScoreNormalize(vector<vector<double>> \&data) {

    int rows = data.size();

    int cols = data\[0].size();



    vector<double> mean(cols, 0), stddev(cols, 0);



    for (int j = 0; j < cols; j++) {

        double sum = 0;

        for (int i = 0; i < rows; i++) sum += data\[i]\[j];

        mean\[j] = sum / rows;



        double sq\_sum = 0;

        for (int i = 0; i < rows; i++) sq\_sum += pow(data\[i]\[j] - mean\[j], 2);

        stddev\[j] = sqrt(sq\_sum / rows);

    }



    vector<vector<double>> normalized(rows, vector<double>(cols, 0));

    for (int i = 0; i < rows; i++) {

        for (int j = 0; j < cols; j++) {

            if (stddev\[j] != 0)

                normalized\[i]\[j] = (data\[i]\[j] - mean\[j]) / stddev\[j];

            else

                normalized\[i]\[j] = 0;

        }

    }

    return normalized;

}



// ---------- Write CSV ----------

void write\_csv(string filename, vector<vector<string>> \&header, vector<vector<double>> \&normalized) {

    ofstream output(filename);

    int cols = header\[0].size();



    for (int i = 0; i < cols; i++) {

        output << header\[0]\[i];

        if (i < cols - 1) output << ",";

    }

    output << "\\n";



    for (int i = 0; i < normalized.size(); i++) {

        for (int j = 0; j < cols; j++) {

            output << fixed << setprecision(2) << normalized\[i]\[j];

            if (j < cols - 1) output << ",";

        }

        output << "\\n";

    }

    output.close();

}



int main() {

    string filename = "data.csv";

    vector<vector<string>> data = read\_csv(filename);



    if (data.empty()) {

        cout << "Empty file!" << endl;

        return 0;

    }



    vector<string> header = data\[0];

    data.erase(data.begin());



    int rows = data.size();

    int cols = data\[0].size();



    vector<vector<double>> double\_data(rows, vector<double>(cols, 0));

    for (int i = 0; i < rows; i++) {

        for (int j = 0; j < cols; j++) {

            try {

                double\_data\[i]\[j] = stod(data\[i]\[j]);

            } catch (...) {

                double\_data\[i]\[j] = 0;

            }

        }

    }



    // ----- Perform both normalizations -----

    vector<vector<double>> minmax = minMaxNormalize(double\_data, 0, 1);

    vector<vector<double>> zscore = zScoreNormalize(double\_data);



    // ----- Write results -----

    vector<vector<string>> headerVec = { header };

    write\_csv("normalized\_minmax.csv", headerVec, minmax);

    write\_csv("normalized\_zscore.csv", headerVec, zscore);



    cout << "✅ Min-Max and Z-Score normalization completed.\\n";

    cout << "Files saved as 'normalized\_minmax.csv' and 'normalized\_zscore.csv'.\\n";



    return 0;

}

Age,Height,Weight

18,165,58

19,170,62

20,172,65

21,168,60

22,175,68

23,180,70

24,178,72

25,182,75

26,176,69

27,174,71





### **2.olap**



\#include <bits/stdc++.h>

using namespace std;



// Read CSV file

vector<map<string, string>> readCSV(const string\& fileName, vector<string>\& header) {

    vector<map<string, string>> records;

    ifstream file(fileName);

    if (!file.is\_open()) {

        cout << "Error opening file!" << endl;

        return records;

    }

    string line;

    if (!getline(file, line)) return records;

    stringstream ss(line);

    string col;

    while (getline(ss, col, ',')) header.push\_back(col);



    while (getline(file, line)) {

        stringstream row(line);

        string value;

        map<string, string> record;

        for (int i = 0; i < header.size(); i++) {

            getline(row, value, ',');

            record\[header\[i]] = value;

        }

        records.push\_back(record);

    }

    return records;

}



// Print record

void printRecord(const map<string, string>\& r, const vector<string>\& header) {

    for (const string\& h : header)

        cout << r.at(h) << " | ";

    cout << endl;

}



// ✅ Renamed from 'slice' to 'sliceData'

void sliceData(const vector<map<string, string>>\& data, const string\& field,

               const string\& value, const vector<string>\& header) {

    cout << "\\nSlice: " << field << " = " << value << endl;

    for (const auto\& r : data)

        if (r.at(field) == value)

            printRecord(r, header);

}



// Dice

void dice(const vector<map<string, string>>\& data, const map<string, string>\& filters,

          const vector<string>\& header) {

    cout << "\\nDice result:\\n";

    for (const auto\& r : data) {

        bool match = true;

        for (const auto\& f : filters)

            if (r.at(f.first) != f.second) { match = false; break; }

        if (match) printRecord(r, header);

    }

}



// Roll-up

void rollup(const vector<map<string, string>>\& data, const string\& groupField, const string\& numericField) {

    cout << "\\nRoll-Up by " << groupField << " (sum of " << numericField << ")\\n";

    map<string, double> totals;

    for (const auto\& r : data) {

        try {

            double val = stod(r.at(numericField));

            totals\[r.at(groupField)] += val;

        } catch (...) {

            cout << "Column not numeric!\\n";

            return;

        }

    }

    for (auto\& t : totals)

        cout << t.first << " → " << t.second << endl;

}



// Drill-down

void drilldown(const vector<map<string, string>>\& data, const vector<string>\& header) {

    cout << "\\nDrill-down view:\\n";

    for (const auto\& r : data)

        printRecord(r, header);

}



// Pivot

void pivot(const vector<map<string, string>>\& data, const string\& rowField,

           const string\& colField, const string\& numericField) {

    cout << "\\nPivot (" << rowField << " vs " << colField << ")\\n";

    map<string, map<string, double>> pivot;

    set<string> colValues;



    for (const auto\& r : data) {

        try {

            double val = stod(r.at(numericField));

            string row = r.at(rowField);

            string col = r.at(colField);

            colValues.insert(col);

            pivot\[row]\[col] += val;

        } catch (...) {

            cout << "Column not numeric!\\n";

            return;

        }

    }



    cout << rowField << "\\t";

    for (const string\& col : colValues) cout << col << "\\t";

    cout << endl;



    for (const auto\& rowPair : pivot) {

        cout << rowPair.first << "\\t";

        for (const string\& col : colValues)

            cout << rowPair.second.at(col) << "\\t";

        cout << endl;

    }

}



int main() {

    string fileName;

    cout << "Enter CSV file name: ";

    getline(cin, fileName);



    vector<string> header;

    vector<map<string, string>> data = readCSV(fileName, header);



    if (data.empty()) {

        cout << "No data found!\\n";

        return 0;

    }



    cout << "\\nColumns: ";

    for (auto\& h : header) cout << h << " ";

    cout << endl;



    while (true) {

        cout << "\\n--- OLAP MENU ---\\n";

        cout << "1. Show Data\\n2. Slice\\n3. Dice\\n4. Roll-Up\\n5. Drill-Down\\n6. Pivot\\n0. Exit\\nChoice: ";

        int ch; cin >> ch; cin.ignore();



        if (ch == 1) {

            for (auto\& r : data) printRecord(r, header);



        } else if (ch == 2) {

            string field, value;

            cout << "Field: "; getline(cin, field);

            cout << "Value: "; getline(cin, value);

            sliceData(data, field, value, header);  // ✅ renamed



        } else if (ch == 3) {

            int n;

            cout << "How many filters? "; cin >> n; cin.ignore();

            map<string, string> filters;

            for (int i = 0; i < n; i++) {

                string f, v;

                cout << "Field: "; getline(cin, f);

                cout << "Value: "; getline(cin, v);

                filters\[f] = v;

            }

            dice(data, filters, header);



        } else if (ch == 4) {

            string group, num;

            cout << "Group by field: "; getline(cin, group);

            cout << "Numeric field: "; getline(cin, num);

            rollup(data, group, num);



        } else if (ch == 5) {

            drilldown(data, header);



        } else if (ch == 6) {

            string row, col, num;

            cout << "Row field: "; getline(cin, row);

            cout << "Column field: "; getline(cin, col);

            cout << "Numeric field: "; getline(cin, num);

            pivot(data, row, col, num);



        } else if (ch == 0) {

            cout << "Goodbye!\\n";

            break;

        } else {

            cout << "Invalid choice!\\n";

        }

    }

    return 0;

}

Name,Department,IQ,Prev\_Sem\_Result,CGPA,Academic\_Performance,Extra\_Curricular\_Score,Communication\_Skills,Projects\_Completed

Amit,IT,120,85,8.2,90,80,75,4

Riya,CS,110,88,8.5,85,70,80,5

Kabir,IT,130,82,8.0,88,60,70,3

Sneha,ENTC,115,79,7.5,83,90,78,4

Aryan,CS,125,91,9.0,92,85,88,6

Neha,IT,118,87,8.1,86,75,76,4





#### **3.tweight dweight**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

using namespace std;



struct Row {

    string class\_name;

    int cat1;

    int cat2;

};



int main() {

    ifstream file("input.csv");

    if (!file) {

        cout << "File not found!\\n";

        return 1;

    }



    string line;

    vector<Row> data;

    int totalCat1 = 0, totalCat2 = 0;



    getline(file, line); // skip header line

    while (getline(file, line)) {

        stringstream ss(line);

        string className, c1s, c2s;



        getline(ss, className, ',');

        getline(ss, c1s, ',');

        getline(ss, c2s, ',');



        int cat1 = stoi(c1s);

        int cat2 = stoi(c2s);



        Row r;

        r.class\_name = className;

        r.cat1 = cat1;

        r.cat2 = cat2;

        data.push\_back(r);



        totalCat1 += cat1;

        totalCat2 += cat2;

    }

    file.close();



    ofstream out("twt\_dwt\_output.csv");

    out << "Class,Category1,Twt,Dwt,Category2,Twt,Dwt,Total\\n";



    cout << "\\nTwt and Dwt Results:\\n\\n";

    cout << "Class         Cat1   Twt%   Dwt%   Cat2   Twt%   Dwt%   Total\\n";



    for (int i = 0; i < data.size(); i++) {

        string name = data\[i].class\_name;

        int cat1 = data\[i].cat1;

        int cat2 = data\[i].cat2;

        int total = cat1 + cat2;



        double cat1Twt = (cat1 \* 100.0) / total;

        double cat1Dwt = (cat1 \* 100.0) / totalCat1;

        double cat2Twt = (cat2 \* 100.0) / total;

        double cat2Dwt = (cat2 \* 100.0) / totalCat2;



        cout << name << "   " << cat1 << "   " << cat1Twt << "   " << cat1Dwt

             << "   " << cat2 << "   " << cat2Twt << "   " << cat2Dwt

             << "   " << total << endl;



        out << name << "," << cat1 << "," << cat1Twt << "%," << cat1Dwt << "%,"

            << cat2 << "," << cat2Twt << "%," << cat2Dwt << "%," << total << "\\n";

    }



    cout << "Total         " << totalCat1 << "   100   100   " << totalCat2

         << "   100   100   " << totalCat1 + totalCat2 << endl;



    out << "Total," << totalCat1 << ",100%,100%," << totalCat2

        << ",100%,100%," << totalCat1 + totalCat2 << "\\n";



    out.close();



    cout << "\\nSaved to twt\_dwt\_output.csv\\n";

    return 0;

}

Location,TV,Computer

Europe,80,240

North America,120,560







#### **4.Boxplot**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <string>

\#include <climits>

\#include <iomanip>

\#include <cmath>

\#include <algorithm>

using namespace std;



vector<double> read\_csv(string \&filename) {

    ifstream file(filename);

    vector<double> data;

    if (!file.is\_open()) {

        cout << "Error opening file!" << endl;

        return data;

    }



    string line, header;

    getline(file, header); // skip header



    while (getline(file, line)) {

        if (!line.empty())

            data.push\_back(stod(line));

    }



    file.close();

    return data;

}



double median(vector<double> \&data) {

    int n = data.size();

    if (n == 0) return 0;

    if (n % 2 == 0)

        return (data\[n / 2 - 1] + data\[n / 2]) / 2.0;

    else

        return data\[n / 2];

}



int main() {

    string filename = "data.csv";

    vector<double> data = read\_csv(filename);



    if (data.empty()) {

        cout << "No data found!" << endl;

        return 0;

    }



    sort(data.begin(), data.end());

    int n = data.size();



    double Q2 = median(data);



    vector<double> lower\_half, upper\_half;

    int mid = n / 2;



    if (n % 2 == 0) {

        lower\_half = vector<double>(data.begin(), data.begin() + mid);

        upper\_half = vector<double>(data.begin() + mid, data.end());

    } else {

        lower\_half = vector<double>(data.begin(), data.begin() + mid);

        upper\_half = vector<double>(data.begin() + mid + 1, data.end());

    }



    double Q1 = median(lower\_half);

    double Q3 = median(upper\_half);

    double IQR = Q3 - Q1;



    double lower\_bound = Q1 - 1.5 \* IQR;

    double upper\_bound = Q3 + 1.5 \* IQR;



    double minVal = data\[0], maxVal = data\[n - 1];



    cout << "\\n--- Outliers ---\\n";

    for (double val : data) {

        if (val < lower\_bound || val > upper\_bound)

            cout << val << " ";

    }

    cout << "\\n";



    // Update min/max excluding outliers

    for (double val : data) {

        if (val >= lower\_bound) {

            minVal = val;

            break;

        }

    }

    for (int i = n - 1; i >= 0; i--) {

        if (data\[i] <= upper\_bound) {

            maxVal = data\[i];

            break;

        }

    }



    cout << fixed << setprecision(2);

    cout << "\\nFive Number Summary:\\n";

    cout << "Min: " << minVal << endl;

    cout << "Q1 : " << Q1 << endl;

    cout << "Q2 : " << Q2 << endl;

    cout << "Q3 : " << Q3 << endl;

    cout << "Max: " << maxVal << endl;



    return 0;

}



Math

14

16

18

12

13

17

15

19

35

20





#### **Apriori:**

\#include <bits/stdc++.h>

using namespace std;



// Function to calculate support count of an itemset

int getSupportCount(const set<string> \&itemset, const vector<set<string>> \&transactions) {

    int count = 0;

    for (auto \&transaction : transactions) {

        if (includes(transaction.begin(), transaction.end(), itemset.begin(), itemset.end()))

            count++;

    }

    return count;

}



// Helper function to print a set nicely

void printSet(const set<string> \&s) {

    int idx = 0;

    cout << "{";

    for (auto \&item : s) {

        if (idx++) cout << ",";

        cout << item;

    }

    cout << "}";

}



// Generate all non-empty proper subsets of an itemset

vector<set<string>> getSubsets(const set<string> \&itemset) {

    vector<string> items(itemset.begin(), itemset.end());

    int n = items.size();

    vector<set<string>> subsets;



    for (int size = 1; size < n; ++size) {

        vector<bool> select(n, false);

        fill(select.begin(), select.begin() + size, true);



        do {

            set<string> subset;

            for (int i = 0; i < n; ++i) {

                if (select\[i]) subset.insert(items\[i]);

            }

            subsets.push\_back(subset);

        } while (prev\_permutation(select.begin(), select.end()));

    }



    return subsets;

}



int main() {

    // --- Read transactions from CSV ---

    ifstream file("transactions.csv");

    if (!file.is\_open()) {

        cout << "Error: Could not open transactions.csv\\n";

        return 0;

    }



    vector<set<string>> transactions;

    string line;

    while (getline(file, line)) {

        stringstream ss(line);

        string item;

        set<string> transaction;

        while (getline(ss, item, ',')) {

            if (!item.empty())

                transaction.insert(item);

        }

        if (!transaction.empty())

            transactions.push\_back(transaction);

    }

    file.close();



    // --- Input minimum support and confidence ---

    double minSupportInput, minConfidence;

    cout << "Enter minimum support (0-1): ";

    cin >> minSupportInput;

    cout << "Enter minimum confidence (0-1): ";

    cin >> minConfidence;



    int minCount = ceil(minSupportInput \* transactions.size());

    map<int, map<set<string>, int>> frequentItemsets;



    // --- Step 1: Count all 1-itemsets ---

    for (auto \&transaction : transactions) {

        for (auto \&item : transaction)

            frequentItemsets\[1]\[{item}]++;

    }



    // Remove 1-itemsets below min support

    for (auto it = frequentItemsets\[1].begin(); it != frequentItemsets\[1].end();) {

        if (it->second < minCount)

            it = frequentItemsets\[1].erase(it);

        else

            ++it;

    }



    // --- Step 2: Generate k-itemsets (k>=2) ---

    int k = 2;

    while (!frequentItemsets\[k-1].empty()) {

        vector<set<string>> prevLevel;

        for (auto \&p : frequentItemsets\[k-1])

            prevLevel.push\_back(p.first);



        for (int i = 0; i < prevLevel.size(); ++i) {

            for (int j = i + 1; j < prevLevel.size(); ++j) {

                set<string> candidate = prevLevel\[i];

                candidate.insert(prevLevel\[j].begin(), prevLevel\[j].end());



                if (candidate.size() == k) {

                    int supportCount = getSupportCount(candidate, transactions);

                    if (supportCount >= minCount)

                        frequentItemsets\[k]\[candidate] = supportCount;

                }

            }

        }

        k++;

    }



    // --- Step 3: Print all frequent itemsets (support >= minSupport) ---

    cout << "\\n=== Frequent Itemsets (support >= " << minSupportInput << ") ===\\n";

    for (auto \&level : frequentItemsets) {

        if (level.second.empty()) continue;

        for (auto \&p : level.second) {

            printSet(p.first);

            cout << " -> support=" << round((double)p.second / transactions.size()\*100.0)/100.0 << endl;

        }

    }



    // --- Step 4: Generate Association Rules satisfying minConfidence ---

    cout << "\\n=== Association Rules (minConfidence = " << minConfidence << ") ===\\n";

    for (auto \&level : frequentItemsets) {

        if (level.first < 2) continue;



        for (auto \&entry : level.second) {

            const set<string> \&itemset = entry.first;

            int itemsetSupport = entry.second;



            auto subsets = getSubsets(itemset);

            for (auto \&A : subsets) {

                set<string> B;

                for (auto \&item : itemset)

                    if (A.find(item) == A.end()) B.insert(item);



                double confidence = (double)itemsetSupport / getSupportCount(A, transactions);

                if (confidence >= minConfidence) {

                    printSet(A);

                    cout << " => ";

                    printSet(B);

                    cout << " (conf=" << round(confidence\*100.0)/100.0

                         << ", support=" << round((double)itemsetSupport/transactions.size()\*100.0)/100.0 << ")\\n";

                }

            }

        }

    }



    return 0;

}

Milk,Bread,Butter

Bread,Egg

Milk,Butter,Egg

Milk,Bread,Egg

Bread,Butter

Milk,Butter





#### **7.apriori**



\#include<bits/stdc++.h>

using namespace std;



int main() {

    ifstream file("data.csv");

    string line;

    vector<vector<double>> data;



    // Read CSV data

    while (getline(file, line)) {

        stringstream ss(line);

        string val;

        vector<double> row;

        while (getline(ss, val, ',')) {

            row.push\_back(stod(val));

        }

        if (!row.empty()) data.push\_back(row);

    }

    file.close();



    int n = data.size();

    int m = data\[0].size();



    // Compute correlation for each pair of columns

    for (int i = 0; i < m; i++) {

        for (int j = i + 1; j < m; j++) {

            double sumx = 0, sumy = 0, sumxy = 0, sumx2 = 0, sumy2 = 0;



            for (int k = 0; k < n; k++) {

                double x = data\[k]\[i];

                double y = data\[k]\[j];

                sumx += x;

                sumy += y;

                sumxy += x \* y;

                sumx2 += x \* x;

                sumy2 += y \* y;

            }



            double num = (n \* sumxy) - (sumx \* sumy);

            double den = sqrt((n \* sumx2 - sumx \* sumx) \* (n \* sumy2 - sumy \* sumy));



            double corr = (den != 0) ? num / den : 0;



            cout << "Correlation between column " << i + 1

                 << " and column " << j + 1 << " = " << corr << endl;

        }

    }



    return 0;

}

2.5,3.6,4.1,10.2

3.1,4.0,5.0,12.3

4.0,5.2,6.1,14.4

4.8,5.9,6.8,15.0

5.2,6.3,7.5,16.8

6.0,7.1,8.0,18.2

6.5,7.4,8.6,19.5

7.2,8.0,9.1,20.3

8.0,8.8,9.8,22.1

8.5,9.2,10.3,23.5





#### **8.k-means**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <cmath>

\#include <limits>



using namespace std;



double euclideanDistance(const vector<double> \&a, const vector<double> \&b) {

    double sum = 0.0;

    for (int i = 0; i < a.size(); i++)

        sum += pow(a\[i] - b\[i], 2);

    return sqrt(sum);

}



int main() {

    ifstream file("data.csv");

    string header;

    getline(file, header);



    vector<vector<double>> data;

    string line;

    while (getline(file, line)) {

        stringstream ss(line);

        string value;

        vector<double> row;

        while (getline(ss, value, ',')) {

            if (!value.empty())

                row.push\_back(stod(value));

        }

        if (!row.empty())

            data.push\_back(row);

    }

    file.close();



    int n = data.size();

    int dim = data\[0].size();

    cout << "Data loaded: " << n << " points, " << dim << " dimensions.\\n";



    int k;

    cout << "Enter number of clusters: ";

    cin >> k;



    vector<vector<double>> centroids(k, vector<double>(dim));

    vector<vector<double>> centroidSum(k, vector<double>(dim));

    vector<int> count(k, 0);

    vector<int> label(n, -1);



    for (int i = 0; i < k; i++)

        centroids\[i] = data\[i];



    bool changed = true;

    int step = 0;

    while (changed \&\& step < 100) {

        changed = false;

        step++;

        cout << "\\n--- Step " << step << " ---\\n";



        // Reset sums and counts

        for (int i = 0; i < k; i++) {

            count\[i] = 0;

            fill(centroidSum\[i].begin(), centroidSum\[i].end(), 0.0);

        }



        // Assign points to nearest centroid

        for (int i = 0; i < n; i++) {

            double minDist = INT\_MAX;

            int best = -1;



            for (int c = 0; c < k; c++) {

                double dist = euclideanDistance(data\[i], centroids\[c]);

                if (dist < minDist) {

                    minDist = dist;

                    best = c;

                }

            }



            if (label\[i] != best)

                changed = true;



            label\[i] = best;



            // Add point to centroid sum

            for (int d = 0; d < dim; d++)

                centroidSum\[best]\[d] += data\[i]\[d];



            count\[best]++;

        }



        // Update centroids

        for (int c = 0; c < k; c++) {

            if (count\[c] > 0) {

                for (int d = 0; d < dim; d++)

                    centroids\[c]\[d] = centroidSum\[c]\[d] / count\[c];

            }

        }



        // --- Print current centroids and cluster points ---

        for (int c = 0; c < k; c++) {

            cout << "Cluster " << c + 1 << " centroid: ";

            for (int d = 0; d < dim; d++)

                cout << centroids\[c]\[d] << " ";

            cout << "\\nPoints: ";

            for (int i = 0; i < n; i++)

                if (label\[i] == c)

                    cout << "P" << i + 1 << " ";

            cout << "\\n";

        }

    }



    cout << "\\nK-means clustering completed in " << step << " steps!\\n";



    return 0;

}



X,Y

1.0,2.0

1.5,1.8

5.0,8.0

8.0,8.0

1.0,0.6

9.0,11.0

8.0,2.0

10.0,2.0

9.0,3.0







#### **9.hierarchical**

1.single

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double, double> a, pair<double, double> b) {

    return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

    ifstream file("data.csv");

    vector<pair<double, double>> points;

    double x, y;

    char comma;

    while(file >> x >> comma >> y)

        points.push\_back({x, y});

    file.close();



    int n = points.size();



    // Initialize clusters: each cluster stores indices of points

    vector<vector<int>> clusters;

    for(int i = 0; i < n; i++)

        clusters.push\_back({i});



    // Print initial clusters

    cout << "Initial clusters:\\n";

    for(int i = 0; i < n; i++)

        cout << "P" << i+1 << " ";

    cout << "\\n\\n";



    while(clusters.size() > 1) {

        double minDist = INT\_MAX;

        int idxA = -1, idxB = -1;



        // Find closest pair of clusters (single linkage)

        for(int i = 0; i < clusters.size(); i++) {

            for(int j = i+1; j < clusters.size(); j++) {

                double d = 1e9;

                for(int p1 : clusters\[i])

                    for(int p2 : clusters\[j])

                        d = min(d, euclideanDistance(points\[p1], points\[p2]));

                if(d < minDist) {

                    minDist = d;

                    idxA = i;

                    idxB = j;

                }

            }

        }



        // Merge clusters

        vector<int> merged = clusters\[idxA];

        merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());



        // Print merge info

        cout << "Merging clusters: ";

        for(int p : clusters\[idxA]) cout << "P" << p+1 << " ";

        cout << "and ";

        for(int p : clusters\[idxB]) cout << "P" << p+1 << " ";

        cout << "(distance = " << minDist << ")\\n";



        // Remove old clusters and add merged

        if(idxA < idxB) {

            clusters.erase(clusters.begin() + idxB);

            clusters.erase(clusters.begin() + idxA);

        }

        else { clusters.erase(clusters.begin() + idxA);

            clusters.erase(clusters.begin() + idxB);

        }

        clusters.push\_back(merged);

    }



    // Print final cluster

    cout << "\\nFinal Cluster: ";

    for(int p : clusters\[0]) cout << "P" << p+1 << " ";

    cout << "\\n";



    return 0;

}



2.complete

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double,double> a, pair<double,double> b) {

    return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

    ifstream file("data.csv");

    vector<pair<double,double>> points;

    double x, y;

    char comma;

    while(file >> x >> comma >> y)

        points.push\_back({x,y});

    file.close();



    int n = points.size();



    // Each cluster stores the indices of points

    vector<vector<int>> clusters;

    vector<string> clusterNames;

    for(int i = 0; i < n; i++) {

        clusters.push\_back({i});

        clusterNames.push\_back("P" + to\_string(i+1));

    }



    cout << "Initial clusters:\\n";

    for(auto \&name : clusterNames) cout << name << " ";

    cout << "\\n\\n";



    while(clusters.size() > 1) {

        double minDist = 1e9;

        int idxA=-1, idxB=-1;



        // Find closest pair of clusters (complete linkage)

        for(int i = 0; i < clusters.size(); i++) {

            for(int j = i+1; j < clusters.size(); j++) {

                double d = 0; // complete linkage → max distance

                for(int p1 : clusters\[i])

                    for(int p2 : clusters\[j])

                        d = max(d, euclideanDistance(points\[p1], points\[p2]));

                if(d < minDist) {

                    minDist = d;

                    idxA = i;

                    idxB = j;

                }

            }

        }



        // Merge clusters

        vector<int> merged = clusters\[idxA];

        merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());

        string mergedName = "(" + clusterNames\[idxA] + "," + clusterNames\[idxB] + ")";



        // Print merge info

        cout << "Merging " << clusterNames\[idxA] << " and " << clusterNames\[idxB]

             << " => " << mergedName << " (distance = " << minDist << ")\\n";



        // Remove old clusters and add merged

        if(idxA < idxB) {

            clusters.erase(clusters.begin() + idxB);

            clusters.erase(clusters.begin() + idxA);

            clusterNames.erase(clusterNames.begin() + idxB);

            clusterNames.erase(clusterNames.begin() + idxA);

        } else {

            clusters.erase(clusters.begin() + idxA);

            clusters.erase(clusters.begin() + idxB);

            clusterNames.erase(clusterNames.begin() + idxA);

            clusterNames.erase(clusterNames.begin() + idxB);

        }



        clusters.push\_back(merged);

        clusterNames.push\_back(mergedName);

    }



    cout << "\\nFinal Cluster: " << clusterNames\[0] << "\\n";

    return 0;

}



3.average

\#include <bits/stdc++.h>

using namespace std;



// Euclidean distance between two points

double euclideanDistance(pair<double,double> a, pair<double,double> b) {

    return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));

}



int main() {

    ifstream file("data.csv");

    vector<pair<double,double>> points;

    double x, y;

    char comma;

    while(file >> x >> comma >> y)

        points.push\_back({x,y});

    file.close();



    int n = points.size();



    // Each cluster stores the indices of points

    vector<vector<int>> clusters;

    vector<string> clusterNames;

    for(int i = 0; i < n; i++) {

        clusters.push\_back({i});

        clusterNames.push\_back("P" + to\_string(i+1));

    }



    cout << "Initial clusters:\\n";

    for(auto \&name : clusterNames) cout << name << " ";

    cout << "\\n\\n";



    while(clusters.size() > 1) {

        double minDist = 1e9;

        int idxA=-1, idxB=-1;



        // Find closest pair of clusters (average linkage)

        for(int i = 0; i < clusters.size(); i++) {

            for(int j = i+1; j < clusters.size(); j++) {

                double sumDist = 0;

                int count = 0;

                for(int p1 : clusters\[i]) {

                    for(int p2 : clusters\[j]) {

                        sumDist += euclideanDistance(points\[p1], points\[p2]);

                        count++;

                    }

                }

                double avgDist = sumDist / count; // average distance

                if(avgDist < minDist) {

                    minDist = avgDist;

                    idxA = i;

                    idxB = j;

                }

            }

        }



        // Merge clusters

        vector<int> merged = clusters\[idxA];

        merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());

        string mergedName = "(" + clusterNames\[idxA] + "," + clusterNames\[idxB] + ")";



        // Print merge info

        cout << "Merging " << clusterNames\[idxA] << " and " << clusterNames\[idxB]

             << " => " << mergedName << " (distance = " << minDist << ")\\n";



        // Remove old clusters and add merged

        if(idxA < idxB) {

            clusters.erase(clusters.begin() + idxB);

            clusters.erase(clusters.begin() + idxA);

            clusterNames.erase(clusterNames.begin() + idxB);

            clusterNames.erase(clusterNames.begin() + idxA);

        } else {

            clusters.erase(clusters.begin() + idxA);

            clusters.erase(clusters.begin() + idxB);

            clusterNames.erase(clusterNames.begin() + idxA);

            clusterNames.erase(clusterNames.begin() + idxB);

        }



        clusters.push\_back(merged);

        clusterNames.push\_back(mergedName);

    }



    cout << "\\nFinal Cluster: " << clusterNames\[0] << "\\n";

    return 0;

}



1,1

1.2,1.1

2.1,6

5.8,9

8,8

8.2,8.1



#### **10.DBSCAN**



\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <cmath>

using namespace std;



struct Point {

    vector<double> coords; // store all dimensions

    int cluster;

};





double distance(const Point \&a, const Point \&b) {

    double sum = 0.0;

    for (size\_t i = 0; i < a.coords.size(); i++) {

        sum += pow(a.coords\[i] - b.coords\[i], 2);

    }

    return sqrt(sum);

}





vector<int> getNeighbors(const vector<Point> \&points, int idx, double eps) {

    vector<int> neighbors;

    for (int i = 0; i < points.size(); i++) {

        if (distance(points\[idx], points\[i]) <= eps)

            neighbors.push\_back(i);

    }

    return neighbors;

}



void expandCluster(vector<Point> \&points, int idx, vector<int> neighbors,

                   int clusterId, double eps, int minPts) {

    points\[idx].cluster = clusterId;



    for (int i = 0; i < neighbors.size(); i++) {

        int nIdx = neighbors\[i];



        if (points\[nIdx].cluster == 0) { // unvisited

            points\[nIdx].cluster = clusterId;

            vector<int> newNeighbors = getNeighbors(points, nIdx, eps);



            if (newNeighbors.size() >= minPts)

                neighbors.insert(neighbors.end(), newNeighbors.begin(), newNeighbors.end());

        }



        if (points\[nIdx].cluster == -1) // was noise

            points\[nIdx].cluster = clusterId;

    }

}



int main() {

   ifstream file("data.csv");

vector<Point> points;

string line;



while (getline(file, line)) {

    stringstream ss(line);

    string value;

    Point p;

    while (getline(ss, value, ',')) {

        p.coords.push\_back(stod(value)); // add each dimension

    }

    p.cluster = 0;

    points.push\_back(p);

}

    double eps;

    int minPts;

    cout << "Enter eps and minPts: ";

    cin >> eps >> minPts;



    int clusterId = 0;



    for (int i = 0; i < points.size(); i++) {

        if (points\[i].cluster != 0) continue;

 

        vector<int> neighbors = getNeighbors(points, i, eps);



        if (neighbors.size() < minPts) {

            points\[i].cluster = -1; // mark as noise

        } else {

            clusterId++;

            expandCluster(points, i, neighbors, clusterId, eps, minPts);

        }

    }



    cout << "\\n=== DBSCAN Clustering Result ===\\n";

for (int i = 0; i < points.size(); i++) {

    cout << "(";

    for (int j = 0; j < points\[i].coords.size(); j++) {

        cout << points\[i].coords\[j];

        if (j != points\[i].coords.size() - 1)

            cout << ", ";

    }

    cout << ") -> ";

 

    if (points\[i].cluster == -1)

        cout << "Noise\\n";

    else

        cout << "Cluster " << points\[i].cluster << "\\n";

}



    return 0;

}





1,1,1

1.1,1.2,0.9

8,8,8

8.2,8.1,7.9

0,0,0



#### **12.linear regression**

\#include <iostream>

\#include <fstream>

\#include <sstream>

\#include <vector>

\#include <iomanip>

using namespace std;



int main() {

    ifstream file("data.csv");

    vector<double> dataX, dataY;

    string header;

    getline(file, header); // skip header



    string line;

    while (getline(file, line)) {

        stringstream ss(line);

        string valX, valY;

        if (!getline(ss, valX, ',') || !getline(ss, valY, ',')) continue;

        dataX.push\_back(stod(valX));

        dataY.push\_back(stod(valY));

    }

    file.close();



    int n = dataX.size();

    if (n == 0) {

        cout << "No data found!" << endl;

        return 0;

    }



    // Step 1: Calculate sums

    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

    for (int i = 0; i < n; i++) {

        sumX += dataX\[i];

        sumY += dataY\[i];

        sumXY += dataX\[i] \* dataY\[i];

        sumX2 += dataX\[i] \* dataX\[i];

    }



    cout << fixed << setprecision(4);

    cout << "\\nStep 1: Calculate sums\\n";

    cout << "Sum of X: " << sumX << endl;

    cout << "Sum of Y: " << sumY << endl;

    cout << "Sum of X\*Y: " << sumXY << endl;

    cout << "Sum of X^2: " << sumX2 << endl;



    // Step 2: Calculate slope (m)

    double slope = ((n \* sumXY) - (sumX \* sumY)) / ((n \* sumX2) - (sumX \* sumX));

    cout << "\\nStep 2: Calculate slope (m)\\n";

    cout << "Slope (m) = " << slope << endl;



    // Step 3: Calculate intercept (b)

    double intercept = (sumY - slope \* sumX) / n;

    cout << "\\nStep 3: Calculate intercept (b)\\n";

    cout << "Intercept (b) = " << intercept << endl;



    // Step 4: Make prediction

    double xInput;

    cout << "\\nStep 4: Predict Y for a given X\\n";

    cout << "Enter X value: ";

    cin >> xInput;

    double yPred = intercept + slope \* xInput;

    cout << "Predicted Y = " << yPred << endl;



    return 0;

}

X,Y

1,2

2,3

3,4

4,5

5,7



#### **13.bayes**



\#include<bits/stdc++.h>

using namespace std;



int main() {

    // --- Step 1: Read CSV file ---

    ifstream file("data.csv");

    if (!file.is\_open()) {

        cout << "Error: Unable to open data.csv!" << endl;

        return 0;

    }



    string line;

    getline(file, line); // header

    stringstream header(line);

    vector<string> headers;

    string col;

    while (getline(header, col, ',')) headers.push\_back(col);



    int nAttr = headers.size() - 1;    // last column is class

    string classCol = headers.back();



    vector<vector<string>> data;

    while (getline(file, line)) {

        stringstream ss(line);

        vector<string> row;

        string value;

        while (getline(ss, value, ',')) row.push\_back(value);

        if (!row.empty()) data.push\_back(row);

    }

    file.close();



    int totalRecords = data.size();



    // --- Step 2: Identify all possible classes ---

    vector<string> classes;

    for (auto \&row : data) {

        string cls = row\[nAttr];

        if (find(classes.begin(), classes.end(), cls) == classes.end())

            classes.push\_back(cls);

    }



    // --- Step 3: Input new record ---

    vector<string> newRecord(nAttr);

    cout << "\\nEnter new record values:\\n";

    for (int i = 0; i < nAttr; i++) {

        cout << headers\[i] << ": ";

        cin >> newRecord\[i];

    }



    // --- Step 4: Compute posterior probabilities ---

    vector<double> posterior(classes.size(), 0.0);

    cout << fixed << setprecision(4);



    cout << "\\n--- Step-by-step Posterior Probabilities ---\\n";

    for (int c = 0; c < classes.size(); c++) {

        string classVal = classes\[c];

        int classCount = 0;



        // Count how many records belong to this class

        for (auto \&row : data)

            if (row\[nAttr] == classVal)

                classCount++;



        double prior = (double)classCount / totalRecords;

        double prob = prior;



        cout << "\\nClass '" << classVal << "':\\n";

        cout << "Prior Probability P(" << classVal << ") = " << prior << endl;



        // Multiply conditional probabilities for each attribute

        for (int j = 0; j < nAttr; j++) {

            int match = 0;

            for (auto \&row : data) {

                if (row\[nAttr] == classVal \&\& row\[j] == newRecord\[j])

                    match++;

            }



            double condProb = 0.0;

            if (classCount > 0)

                condProb = (double)match / classCount;



            cout << "P(" << headers\[j] << "=" << newRecord\[j]

                 << " | " << classVal << ") = " << condProb << endl;



            prob \*= condProb;

        }



        posterior\[c] = prob;

        cout << "Posterior Probability for class " << classVal

             << " = " << prob << endl;

    }



    // --- Step 5: Choose class with maximum posterior ---

    double maxProb = -1;

    string predicted;

    for (int c = 0; c < classes.size(); c++) {

        if (posterior\[c] > maxProb) {

            maxProb = posterior\[c];

            predicted = classes\[c];

        }

    }



    // --- Step 6: Display final prediction ---

    cout << "\\nPredicted Class: " << predicted << endl;

    cout << "\\n--- Conclusion ---\\n";

    cout << "The new record is most likely to belong to class '"

         << predicted << "' based on Naive Bayes classification.\\n";



    return 0;

}

Outlook,Temperature,Humidity,Wind,Play

Sunny,Hot,High,Weak,No

Sunny,Hot,High,Strong,No

Overcast,Hot,High,Weak,Yes

Rain,Mild,High,Weak,Yes

Rain,Cool,Normal,Weak,Yes

Rain,Cool,Normal,Strong,No

Overcast,Cool,Normal,Strong,Yes

Sunny,Mild,High,Weak,No

Sunny,Cool,Normal,Weak,Yes

Rain,Mild,Normal,Weak,Yes

Sunny,Mild,Normal,Strong,Yes

Overcast,Mild,High,Strong,Yes

Overcast,Hot,Normal,Weak,Yes

Rain,Mild,High,Strong,No



#### **INfo gain**

\#include <bits/stdc++.h>

using namespace std;



double entropy(const map<string, int>\& classCount) {

&nbsp;   double total = 0.0;

&nbsp;   for (auto \&p : classCount) total += p.second;

&nbsp;   double ent = 0.0;

&nbsp;   for (auto \&p : classCount) {

&nbsp;       if (p.second == 0) continue;

&nbsp;       double p\_i = p.second / total;

&nbsp;       ent -= p\_i \* log2(p\_i);

&nbsp;   }

&nbsp;   return ent;

}



int main() {

&nbsp;   ios::sync\_with\_stdio(false);

&nbsp;   cin.tie(nullptr);



&nbsp;   string filename = "data.csv";

&nbsp;   ifstream file(filename);

&nbsp;   if (!file.is\_open()) {

&nbsp;       cerr << "Error: cannot open " << filename << endl;

&nbsp;       return 1;

&nbsp;   }



&nbsp;   string line;

&nbsp;   getline(file, line);

&nbsp;   vector<string> headers;

&nbsp;   stringstream ss(line);

&nbsp;   string col;

&nbsp;   while (getline(ss, col, ',')) headers.push\_back(col);



&nbsp;   int numCols = headers.size();

&nbsp;   vector<vector<string>> data;

&nbsp;   while (getline(file, line)) {

&nbsp;       stringstream s(line);

&nbsp;       vector<string> row;

&nbsp;       string val;

&nbsp;       while (getline(s, val, ',')) row.push\_back(val);

&nbsp;       if (row.size() == numCols)

&nbsp;           data.push\_back(row);

&nbsp;   }

&nbsp;   file.close();



&nbsp;   int total = data.size();

&nbsp;   string classCol = headers.back();



&nbsp;   map<string, int> classCount;

&nbsp;   for (auto \&row : data) classCount\[row.back()]++;



&nbsp;   double totalEntropy = entropy(classCount);

&nbsp;   cout << fixed << setprecision(6);

&nbsp;   cout << "Overall Entropy = " << totalEntropy << "\\n\\n";



&nbsp;   for (int attr = 0; attr < numCols - 1; ++attr) {

&nbsp;       map<string, map<string, int>> subsets;

&nbsp;       for (auto \&row : data) {

&nbsp;           string attrVal = row\[attr];

&nbsp;           string classVal = row.back();

&nbsp;           subsets\[attrVal]\[classVal]++;

&nbsp;       }



&nbsp;       double weightedEntropy = 0.0;

&nbsp;       for (auto \&kv : subsets) {

&nbsp;           double subsetSize = 0;

&nbsp;           for (auto \&p : kv.second) subsetSize += p.second;

&nbsp;           weightedEntropy += (subsetSize / total) \* entropy(kv.second);

&nbsp;       }



&nbsp;       double infoGain = totalEntropy - weightedEntropy;



&nbsp;       cout << "Attribute: " << headers\[attr] << "\\n";

&nbsp;       cout << "Weighted Entropy = " << weightedEntropy << "\\n";

&nbsp;       cout << "Information Gain = " << infoGain << "\\n\\n";

&nbsp;   }



&nbsp;   return 0;

}

Outlook,Temperature,Humidity,Wind,Class

sunny,hot,high,weak,NoPlay

sunny,hot,high,strong,NoPlay

overcast,hot,high,weak,Play

rain,mild,high,weak,Play

rain,cool,normal,weak,Play

rain,cool,normal,strong,NoPlay

overcast,cool,normal,strong,Play

sunny,mild,high,weak,NoPlay

sunny,cool,normal,weak,Play

rain,mild,normal,weak,Play

sunny,mild,normal,strong,Play

overcast,mild,high,strong,Play

overcast,hot,normal,weak,Play

rain,mild,high,strong,NoPlay

#### 

**Hierarchical MAtrix**

single

\#include <bits/stdc++.h>

using namespace std;



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error: Cannot open data.csv\\n";

&nbsp;       return 0;

&nbsp;   }



&nbsp;   string line;

&nbsp;   getline(file, line);

&nbsp;   stringstream ss(line);

&nbsp;   string val;

&nbsp;   vector<string> labels;

&nbsp;   getline(ss, val, ','); // skip top-left "0" cell

&nbsp;   while (getline(ss, val, ',')) labels.push\_back(val);



&nbsp;   int n = labels.size();

&nbsp;   vector<vector<double>> dist(n, vector<double>(n, 0));



&nbsp;   // Read distance matrix

&nbsp;   for (int i = 0; i < n; i++) {

&nbsp;       getline(file, line);

&nbsp;       stringstream row(line);

&nbsp;       string rowLabel;

&nbsp;       getline(row, rowLabel, ','); // read row label (a,b,c,...)

&nbsp;       for (int j = 0; j < n; j++) {

&nbsp;           getline(row, val, ',');

&nbsp;           dist\[i]\[j] = stod(val);

&nbsp;       }

&nbsp;   }

&nbsp;   file.close();



&nbsp;   // Initial clusters

&nbsp;   vector<vector<int>> clusters;

&nbsp;   for (int i = 0; i < n; i++) clusters.push\_back({i});



&nbsp;   cout << "Initial clusters: ";

&nbsp;   for (auto \&l : labels) cout << l << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while (clusters.size() > 1) {

&nbsp;       double minDist = 1e9;

&nbsp;       int idxA = -1, idxB = -1;



&nbsp;       // Find closest pair of clusters (Single linkage)

&nbsp;       for (int i = 0; i < clusters.size(); i++) {

&nbsp;           for (int j = i + 1; j < clusters.size(); j++) {

&nbsp;               double d = 1e9;

&nbsp;               for (int p1 : clusters\[i])

&nbsp;                   for (int p2 : clusters\[j])

&nbsp;                       d = min(d, dist\[p1]\[p2]);

&nbsp;               if (d < minDist) {

&nbsp;                   minDist = d;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Print merge info

&nbsp;       cout << "Merging cluster { ";

&nbsp;       for (int p : clusters\[idxA]) cout << labels\[p] << " ";

&nbsp;       cout << "} and { ";

&nbsp;       for (int p : clusters\[idxB]) cout << labels\[p] << " ";

&nbsp;       cout << "} at distance = " << minDist << "\\n";



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());



&nbsp;       if (idxA < idxB) {

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;       } else {

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;       }

&nbsp;       clusters.push\_back(merged);

&nbsp;   }



&nbsp;   cout << "\\nFinal Cluster: { ";

&nbsp;   for (int p : clusters\[0]) cout << labels\[p] << " ";

&nbsp;   cout << "}\\n";



&nbsp;   return 0;

}


complete:



\#include <bits/stdc++.h>

using namespace std;



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error: Cannot open data.csv\\n";

&nbsp;       return 0;

&nbsp;   }



&nbsp;   string line;

&nbsp;   getline(file, line);

&nbsp;   stringstream ss(line);

&nbsp;   string val;

&nbsp;   vector<string> labels;

&nbsp;   getline(ss, val, ','); // skip top-left "0" cell

&nbsp;   while (getline(ss, val, ',')) labels.push\_back(val);



&nbsp;   int n = labels.size();

&nbsp;   vector<vector<double>> dist(n, vector<double>(n, 0));



&nbsp;   // Read distance matrix

&nbsp;   for (int i = 0; i < n; i++) {

&nbsp;       getline(file, line);

&nbsp;       stringstream row(line);

&nbsp;       string rowLabel;

&nbsp;       getline(row, rowLabel, ','); // skip row label (a,b,c,...)

&nbsp;       for (int j = 0; j < n; j++) {

&nbsp;           getline(row, val, ',');

&nbsp;           dist\[i]\[j] = stod(val);

&nbsp;       }

&nbsp;   }

&nbsp;   file.close();



&nbsp;   // Initialize clusters

&nbsp;   vector<vector<int>> clusters;

&nbsp;   for (int i = 0; i < n; i++) clusters.push\_back({i});



&nbsp;   cout << "Initial clusters: ";

&nbsp;   for (auto \&l : labels) cout << l << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while (clusters.size() > 1) {

&nbsp;       double minDist = 1e9;

&nbsp;       int idxA = -1, idxB = -1;



&nbsp;       // --- Find closest pair of clusters (Complete linkage) ---

&nbsp;       for (int i = 0; i < clusters.size(); i++) {

&nbsp;           for (int j = i + 1; j < clusters.size(); j++) {

&nbsp;               double d = -1e9;

&nbsp;               for (int p1 : clusters\[i])

&nbsp;                   for (int p2 : clusters\[j])

&nbsp;                       d = max(d, dist\[p1]\[p2]); // <-- MAX distance for complete linkage

&nbsp;               if (d < minDist) {

&nbsp;                   minDist = d;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Print merge info

&nbsp;       cout << "Merging cluster { ";

&nbsp;       for (int p : clusters\[idxA]) cout << labels\[p] << " ";

&nbsp;       cout << "} and { ";

&nbsp;       for (int p : clusters\[idxB]) cout << labels\[p] << " ";

&nbsp;       cout << "} at distance = " << minDist << "\\n";



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());



&nbsp;       if (idxA < idxB) {

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;       } else {

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;       }

&nbsp;       clusters.push\_back(merged);

&nbsp;   }



&nbsp;   cout << "\\nFinal Cluster: { ";

&nbsp;   for (int p : clusters\[0]) cout << labels\[p] << " ";

&nbsp;   cout << "}\\n";



&nbsp;   return 0;

}


Average:

\#include <bits/stdc++.h>

using namespace std;



int main() {

&nbsp;   ifstream file("data.csv");

&nbsp;   if (!file.is\_open()) {

&nbsp;       cout << "Error: Cannot open data.csv\\n";

&nbsp;       return 0;

&nbsp;   }



&nbsp;   string line;

&nbsp;   getline(file, line);

&nbsp;   stringstream ss(line);

&nbsp;   string val;

&nbsp;   vector<string> labels;

&nbsp;   getline(ss, val, ','); // skip top-left cell (0)

&nbsp;   while (getline(ss, val, ',')) labels.push\_back(val);



&nbsp;   int n = labels.size();

&nbsp;   vector<vector<double>> dist(n, vector<double>(n, 0));



&nbsp;   // Read distance matrix

&nbsp;   for (int i = 0; i < n; i++) {

&nbsp;       getline(file, line);

&nbsp;       stringstream row(line);

&nbsp;       string rowLabel;

&nbsp;       getline(row, rowLabel, ','); // skip row label (a,b,c,...)

&nbsp;       for (int j = 0; j < n; j++) {

&nbsp;           getline(row, val, ',');

&nbsp;           dist\[i]\[j] = stod(val);

&nbsp;       }

&nbsp;   }

&nbsp;   file.close();



&nbsp;   // Initialize clusters

&nbsp;   vector<vector<int>> clusters;

&nbsp;   for (int i = 0; i < n; i++) clusters.push\_back({i});



&nbsp;   cout << "Initial clusters: ";

&nbsp;   for (auto \&l : labels) cout << l << " ";

&nbsp;   cout << "\\n\\n";



&nbsp;   while (clusters.size() > 1) {

&nbsp;       double minDist = 1e9;

&nbsp;       int idxA = -1, idxB = -1;



&nbsp;       // --- Find closest pair of clusters (Average Linkage) ---

&nbsp;       for (int i = 0; i < clusters.size(); i++) {

&nbsp;           for (int j = i + 1; j < clusters.size(); j++) {

&nbsp;               double sum = 0.0;

&nbsp;               int count = 0;

&nbsp;               for (int p1 : clusters\[i])

&nbsp;                   for (int p2 : clusters\[j]) {

&nbsp;                       sum += dist\[p1]\[p2];

&nbsp;                       count++;

&nbsp;                   }

&nbsp;               double avgDist = sum / count;

&nbsp;               if (avgDist < minDist) {

&nbsp;                   minDist = avgDist;

&nbsp;                   idxA = i;

&nbsp;                   idxB = j;

&nbsp;               }

&nbsp;           }

&nbsp;       }



&nbsp;       // Print merge info

&nbsp;       cout << "Merging cluster { ";

&nbsp;       for (int p : clusters\[idxA]) cout << labels\[p] << " ";

&nbsp;       cout << "} and { ";

&nbsp;       for (int p : clusters\[idxB]) cout << labels\[p] << " ";

&nbsp;       cout << "} at distance = " << minDist << "\\n";



&nbsp;       // Merge clusters

&nbsp;       vector<int> merged = clusters\[idxA];

&nbsp;       merged.insert(merged.end(), clusters\[idxB].begin(), clusters\[idxB].end());



&nbsp;       if (idxA < idxB) {

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;       } else {

&nbsp;           clusters.erase(clusters.begin() + idxA);

&nbsp;           clusters.erase(clusters.begin() + idxB);

&nbsp;       }

&nbsp;       clusters.push\_back(merged);

&nbsp;   }



&nbsp;   cout << "\\nFinal Cluster: { ";

&nbsp;   for (int p : clusters\[0]) cout << labels\[p] << " ";

&nbsp;   cout << "}\\n";



&nbsp;   return 0;

}


Info gain gini:

#include <bits/stdc++.h>
using namespace std;

// ---------- Helper Functions ----------
double entropy(const vector<string>& y) {
    map<string,int> freq;
    for (auto &v : y) freq[v]++;
    double e = 0, n = y.size();
    for (auto &p : freq) {
        double prob = (double)p.second / n;
        e -= prob * log2(prob);
    }
    return e;
}

double gini(const vector<string>& y) {
    map<string,int> freq;
    for (auto &v : y) freq[v]++;
    double g = 1, n = y.size();
    for (auto &p : freq) {
        double prob = (double)p.second / n;
        g -= prob * prob;
    }
    return g;
}

// ---------- Main ----------
int main() {
    string fname;
    cout << "Enter CSV filename (with extension): ";
    cin >> fname;

    ifstream f(fname);
    if (!f.is_open()) {
        cerr << "Error: File not found!\n";
        return 1;
    }

    string line, cell;
    vector<string> headers;
    vector<vector<string>> data;

    // Read header row
    if (getline(f, line)) {
        stringstream ss(line);
        while (getline(ss, cell, ',')) headers.push_back(cell);
    }

    // Read data rows
    while (getline(f, line)) {
        stringstream ss(line);
        vector<string> row;
        while (getline(ss, cell, ',')) row.push_back(cell);
        if (row.size() == headers.size()) data.push_back(row);
    }
    f.close();

    if (data.empty()) {
        cerr << "Error: No valid data found in file.\n";
        return 1;
    }

    int targetIdx = headers.size() - 1;
    cout << "\nTarget column: " << headers[targetIdx] << "\n";

    // Collect target values
    vector<string> targetVals;
    for (auto &r : data) targetVals.push_back(r[targetIdx]);

    double totalEntropy = entropy(targetVals);

    cout << fixed << setprecision(4);
    cout << "\n=== Attribute Evaluation ===\n";

    double bestGain = -1;
    string bestAttr;

    // Evaluate each attribute (except target)
    for (int a = 0; a < targetIdx; a++) {
        map<string, vector<string>> groups;
        for (auto &r : data)
            groups[r[a]].push_back(r[targetIdx]);

        double weightedEntropy = 0.0;
        double weightedGini = 0.0;

        for (auto &grp : groups) {
            double w = (double)grp.second.size() / data.size();
            weightedEntropy += w * entropy(grp.second);
            weightedGini += w * gini(grp.second);
        }

        double infoGain = totalEntropy - weightedEntropy;

        cout << "\nAttribute: " << headers[a]
             << "\n  Info Gain = " << infoGain
             << "\n  Gini Index = " << weightedGini << "\n";

        if (infoGain > bestGain) {
            bestGain = infoGain;
            bestAttr = headers[a];
        }
    }

    cout << "\n=== Best Attribute for Split ===\n";
    cout << "Based on Information Gain -> " << bestAttr
         << " (Gain = " << bestGain << ")\n";

    cout << "\nEvaluation Complete.\n";
    return 0;
}






